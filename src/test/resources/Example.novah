/*
 comment on
 the module
 */
module novah.example hiding
  ( maybe
  , myFun
  , end
  , sum
  , sum2

  //Types
  , Maybe(Just, Nope)
  , List(..)
  )

// imported prelude
import prelude

import data.perhaps
  ( Perhaps(..)
  , fun1, stuff
  )
/**
 * B as Brain
 */
import control.brain as B
import some.mod (fun1, Type2) as Mod

foreign import type java.util.ArrayList
foreign import ArrayList.add(Object)
foreign import new ArrayList() as newArrayList
foreign import Int:parseInt(String)
foreign import get Int:MIN_VALUE as minValue
//foreign import set some.package.AClass.value as setValue

type Maybe a
  = Nope
  | Just a

type List a =
  Nil
  | Cons a (List a)

type Day
  = Week
  | Weekend

bin = 0B001110

num = 0x123efa7c

doub x = x * 13.87E12

x = fn 3 4 5

stuff
  :: Int
  -> Int
  -> String
stuff v v2 = case v of
  0 -> "0"
  1 -> show v2
  _ -> "oops"

/**
 * Some multi line comment
 * added here
 */
maybe
  :: forall a
  . a
  -> Int
  -> Maybe
maybe def sm = case sm of
  Some x -> B.brain x
  Nope -> def

id :: forall a. a -> a
id x = x

compl :: forall a b c. (a -> b) -> (b -> c) -> a -> c
compl f1 f2 x = f2 (f1 x)

hrt :: Int -> (forall a b. (a -> b) -> b) -> Tyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyype -> Tyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyype -> Int
hrt i f t = 1

sum :: Int -> Int -> Int
sum x y = x + y

const :: forall a. a -> b -> a
const x _ = x

mklist :: Int -> Int -> List (List (Int -> Int))
mklist = todo

  // some comment here
myFun x = case x of
  None -> do
    println "Something" :: Unit
    case 4 of x -> x
    4
  Some (Maybe (Perhaps x y 8)) -> x

ex = \x -> do
  let x = 4
  let y = \p -> 9
  sideEffect (if false then "false" else "true") -1
  x * y

doIt :: Unit -> String
doIt () = do
  println
    "not pure"
      // bla
  fun (\x y -> \z -> do
    println x
    x + 1) "a" (Some (3 + 1) 4)
  let f :: forall a. a -> a
      f x = x
  let y :: Int
      y = f 9
  if y >= 2 then do
    println "big y"
    if x then 1 else 0
  else do
    println "small y"
    0

fact :: Int -> Int
fact x =
  if x <= 1
    then x
    else x * fact (x - 1)

end :: Int
end = 0