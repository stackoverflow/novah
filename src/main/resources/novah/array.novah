/**
 * Functions to work with native Java arrays.
 */
module novah.array

foreign import java.lang.System
foreign import java.util.Arrays
foreign import java.util.Comparator
foreign import java.util.stream.Stream
foreign import novah.Core
foreign import novah.Ref

import novah.java (toComparator)
import novah.option as Option
import novah.stream as Stream

/**
 * Returns the size of this array.
 * Runtime: O(1)
 */
pub
size : Array a -> Int32
size arr = Core#getArrayLength(arr)

/**
 * Returns a stream for this array.
 */
pub
stream : Array a -> Stream a
stream arr = Arrays#stream(arr) as Stream a

/**
 * Collects this stream into an array.
 */
pub
fromStream : Stream a -> Array Object
fromStream = Stream.toArray

/**
 * Returns some value at index for this array if it exists or none.
 * This is a safe version of `arrayGet`.
 * Runtime: O(1)
 */
pub
nth : Int -> Array a -> Option a
nth index arr =
  let len = size arr
  if index < 0 || index >= len
    then None
    else Some (aget index arr)

/**
 * Returns true if the array is empty.
 * Runtime: O(1)
 */
pub
isEmpty : Array a -> Boolean
isEmpty arr = size arr == 0

/**
 * Returns true if the array is not empty.
 * Runtime: O(1)
 */
pub
isNotEmpty : Array a -> Boolean
isNotEmpty arr = size arr != 0

/**
 * Returns the first occurrence of elem in the array for which the predicate returns true.
 * Runtime: O(n)
 */
pub
find : (a -> Boolean) -> Array a -> Option a
find pred arr =
  let atm = atom None
  forEachBreak 0 (size arr) \i ->
    let elem = aget i arr
    if pred elem
      then
        reset (Some elem) atm
        -1
      else 0
  deref atm

/**
 * Returns true if the element is inside the array.
 * Runtime: O(n)
 */
pub
contains : {{ Equals a }} -> a -> Array a -> Boolean
contains {{Equals eq}} elem arr = find (\x -> eq x elem) arr |> Option.isSome

/**
 * Runs function f for every element of this array, ignoring the result.
 * Runtime: O(n)
 */
pub
forEach : Array a -> (a -> Unit) -> Unit
forEach arr f =
  forEachRange (0 ... size arr) \idx ->
    f (aget idx arr)

/**
 * Runs function f for every index and element of this array, ignoring the result.
 * Runtime: O(n)
 */
pub
forEachIndexed : Array a -> (Int32 -> a -> Unit) -> Unit
forEachIndexed arr f =
  forEachRange (0 ... size arr) \idx ->
    f idx (aget idx arr)

/**
 * Maps function f over all elements of this array
 * returning an array of the same size.
 * Runtime: O(n)
 */
pub
map : (a -> b) -> Array a -> Array Object
map f arr =
  let len = size arr
  let res = arrayOf Object#-class len
  forEachRange (0 ... len) \i ->
    aset i (f (aget i arr) as Object) res
  res

/**
 * Returns an array of the elements that match the given predicate.
 * Runtime: O(n)
 */
pub
filter : (a -> Boolean) -> Array a -> Array Object
filter f arr = stream arr |> Stream.filter f |> fromStream

/**
 * Sorts this array in place according to the comparing function.
 */
pub
sortBy : (a -> a -> Ordering) -> Array a -> Unit
sortBy cmp arr =
  let comp = toComparator cmp
  Arrays#sort(arr, comp as Comparator Object)

/**
 * Sorts this array in place according to the elements Ord instance.
 */
pub
sort : {{ Ord a }} -> Array a -> Unit
sort {{Ord _ ord}} arr = sortBy ord.compare arr

/**
 * Returns a new array with the same elements in the reverse order of the input array.
 * Runtime: O(n)
 */
pub
reverse : Array a -> Array a
reverse arr =
  let len = size arr
  let res = emptyCopy arr
  forEachRange (0 ... len) \idx ->
    let i = len - idx - 1
    let elem = aget idx arr
    aset i elem res
  res

/**
 * Reverses this array in place.
 * Runtime: O(n/2)
 */
pub
reversed : Array a -> Unit
reversed arr =
  let len = size arr
  forEachRange (0 ... (len / 2)) \i ->
    let temp = aget i arr
    aset i (aget (len - i - 1) arr) arr
    aset (len - i - 1) temp arr

/**
 * Creates a byte array of the specified size.
 */
pub
byteArray : Int -> ByteArray
byteArray len = Core#mkByteArray(len)

/**
 * Creates a int16 array of the specified size.
 */
pub
int16Array : Int -> Int16Array
int16Array len = Core#mkInt16Array(len)

/**
 * Creates a int32 array of the specified size.
 */
pub
intArray : Int -> Int32Array
intArray len = Core#mkInt32Array(len)

/**
 * Creates a int64 array of the specified size.
 */
pub
int64Array : Int -> Int64Array
int64Array len = Core#mkInt64Array(len)

/**
 * Creates a float32 array of the specified size.
 */
pub
float32Array : Int -> Float32Array
float32Array len = Core#mkFloat32Array(len)

/**
 * Creates a float64 array of the specified size.
 */
pub
floatArray : Int -> Float64Array
floatArray len = Core#mkFloat64Array(len)

/**
 * Creates a char array of the specified size.
 */
pub
charArray : Int -> CharArray
charArray len = Core#mkCharArray(len)

/**
 * Creates a boolean array of the specified size.
 */
pub
booleanArray : Int -> BooleanArray
booleanArray len = Core#mkBooleanArray(len)

/**
 * Returns a copy of this array.
 */
pub
copy : Array a -> Array a
copy arr =
  let dest = emptyCopy arr
  System#arraycopy(arr as Object, 0, dest as Object, 0, size arr)
  dest

/**
 * Returns a new array of the same size and type as the supplied array.
 */
pub
emptyCopy : Array a -> Array a
emptyCopy arr =
  if isEmpty arr
    then arr
    else
      let elem = aget 0 arr as Object
      arrayOf elem#getClass() (size arr) as Array a

/**
 * Sets the element of this byte array at the specified index.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: O(1)
 */
pub
byteaset : Int32 -> Byte -> ByteArray -> Unit
byteaset index x arr = Core#byteArraySet(index, x, arr)

/**
 * Sets the element of this int16 array at the specified index.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: O(1)
 */
pub
int16aset : Int32 -> Int16 -> Int16Array -> Unit
int16aset index x arr = Core#shortArraySet(index, x, arr)

/**
 * Sets the element of this int array at the specified index.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: O(1)
 */
pub
int32aset : Int32 -> Int32 -> Int32Array -> Unit
int32aset index x arr = Core#intArraySet(index, x, arr)

/**
 * Sets the element of this int64 array at the specified index.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: O(1)
 */
pub
int64aset : Int32 -> Int64 -> Int64Array -> Unit
int64aset index x arr = Core#longArraySet(index, x, arr)

/**
 * Sets the element of this float32 array at the specified index.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: O(1)
 */
pub
float32aset : Int32 -> Float32 -> Float32Array -> Unit
float32aset index x arr = Core#floatArraySet(index, x, arr)

/**
 * Sets the element of this float64 array at the specified index.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: O(1)
 */
pub
float64aset : Int32 -> Float64 -> Float64Array -> Unit
float64aset index x arr = Core#doubleArraySet(index, x, arr)

/**
 * Sets the element of this boolean array at the specified index.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: O(1)
 */
pub
booleanaset : Int32 -> Boolean -> BooleanArray -> Unit
booleanaset index x arr = Core#booleanArraySet(index, x, arr)

/**
 * Sets the element of this char array at the specified index.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: O(1)
 */
pub
charaset : Int32 -> Char -> CharArray -> Unit
charaset index x arr = Core#charArraySet(index, x, arr)

/**
 * Returns true if the byte is inside the array.
 * Runtime: O(n)
 */
pub
containsByte : Byte -> ByteArray -> Boolean
containsByte elem arr =
  let found = Ref#new(false)
  let i = Ref#new(0)
  let max = Core#byteArraySize(arr)
  while i#-val < max && not found#-val do
    if arr.[i#-val] == elem then
      found#-val <- true
    i#-val <- i#-val + 1
  found#-val

/**
 * Returns true if the int is inside the array.
 * Runtime: O(n)
 */
pub
containsInt : Int32 -> Int32Array -> Boolean
containsInt elem arr =
  let found = Ref#new(false)
  let i = Ref#new(0)
  let max = Core#intArraySize(arr)
  while i#-val < max && not found#-val do
    if arr.[i#-val] == elem then
      found#-val <- true
    i#-val <- i#-val + 1
  found#-val

/**
 * Returns true if the int16 is inside the array.
 * Runtime: O(n)
 */
pub
containsInt16 : Int16 -> Int16Array -> Boolean
containsInt16 elem arr =
  let found = Ref#new(false)
  let i = Ref#new(0)
  let max = Core#shortArraySize(arr)
  while i#-val < max && not found#-val do
    if arr.[i#-val] == elem then
      found#-val <- true
    i#-val <- i#-val + 1
  found#-val

/**
 * Returns true if the int64 is inside the array.
 * Runtime: O(n)
 */
pub
containsInt64 : Int64 -> Int64Array -> Boolean
containsInt64 elem arr =
  let found = Ref#new(false)
  let i = Ref#new(0)
  let max = Core#longArraySize(arr)
  while i#-val < max && not found#-val do
    if arr.[i#-val] == elem then
      found#-val <- true
    i#-val <- i#-val + 1
  found#-val

/**
 * Returns true if the float32 is inside the array.
 * Runtime: O(n)
 */
pub
containsFloat32 : Float32 -> Float32Array -> Boolean
containsFloat32 elem arr =
  let found = Ref#new(false)
  let i = Ref#new(0)
  let max = Core#floatArraySize(arr)
  while i#-val < max && not found#-val do
    if arr.[i#-val] == elem then
      found#-val <- true
    i#-val <- i#-val + 1
  found#-val

/**
 * Returns true if the float64 is inside the array.
 * Runtime: O(n)
 */
pub
containsFloat64 : Float64 -> Float64Array -> Boolean
containsFloat64 elem arr =
  let found = Ref#new(false)
  let i = Ref#new(0)
  let max = Core#doubleArraySize(arr)
  while i#-val < max && not found#-val do
    if arr.[i#-val] == elem then
      found#-val <- true
    i#-val <- i#-val + 1
  found#-val

/**
 * Returns true if the boolean is inside the array.
 * Runtime: O(n)
 */
pub
containsBoolean : Boolean -> BooleanArray -> Boolean
containsBoolean elem arr =
  let found = Ref#new(false)
  let i = Ref#new(0)
  let max = Core#booleanArraySize(arr)
  while i#-val < max && not found#-val do
    if arr.[i#-val] == elem then
      found#-val <- true
    i#-val <- i#-val + 1
  found#-val

/**
 * Returns true if the char is inside the array.
 * Runtime: O(n)
 */
pub
containsChar : Char -> CharArray -> Boolean
containsChar elem arr =
  let found = Ref#new(false)
  let i = Ref#new(0)
  let max = Core#charArraySize(arr)
  while i#-val < max && not found#-val do
    if arr.[i#-val] == elem then
      found#-val <- true
    i#-val <- i#-val + 1
  found#-val