/**
 * Functions to work with strings.
 */
module novah.string

import novah.list as List

foreign import java.lang.CharSequence
foreign import novah.Ref

/**
 * Returns true if this string is empty or only contains whitespace codepoints.
 */
pub
isBlank : String -> Boolean
isBlank (s : String) = s#isBlank()

/**
 * Returns true if this string is not empty or only contains whitespace codepoints.
 */
pub
isNotBlank : String -> Boolean
isNotBlank (s : String) = not s#isBlank()

/**
 * Returns true if this string is empty.
 */
pub
isEmpty : String -> Boolean
isEmpty (s : String) = s#isEmpty()

/**
 * Returns true if this string is not empty.
 */
pub
isNotEmpty : String -> Boolean
isNotEmpty (s : String) = not s#isEmpty()

/**
 * Returns the size of this string.
 */
pub
size : String -> Int32
size (s : String) = s#length()

/**
 * Returns a lower case version of this string.
 */
pub
lowerCase : String -> String
lowerCase (str : String) = str#toLowerCase()

/**
 * Returns a upper case version of this string.
 */
pub
upperCase : String -> String
upperCase (str : String) = str#toUpperCase()

/**
 * Returns true if this string starts with prefix.
 */
pub
startsWith : String -> String -> Boolean
startsWith prefix (str : String) = str#startsWith(prefix)

/**
 * Returns true if this string ends with suffix.
 */
pub
endsWith : String -> String -> Boolean
endsWith suffix (str : String) = str#endsWith(suffix)

/**
 * Returns true if this string contains the string represented by another.
 */
pub
contains : String -> String -> Boolean
contains another (str : String) = str#contains(another as CharSequence)

/**
 * Returns true if this string contains the character.
 */
pub
containsChar : Char -> String -> Boolean
containsChar char (str : String) = str#contains(toString char as CharSequence)

/**
 * Returns a substring from the given string
 * starting at begin (inclusive) and ending in end (exclusive).
 */
pub
substring : Int32 -> Int32 -> String -> String
substring begin end (str : String) = str#substring(begin, end)

/**
 * Returns a substring from the given string starting from begin.
 */
pub
startFrom : Int32 -> String -> String
startFrom begin (str : String) = str#substring(begin)

/**
 * Encodes this string into an array of bytes using the platform's default charset.
 */
pub
getBytes : String -> ByteArray
getBytes (str : String) = str#getBytes()

/**
 * Joins all strings in this list separated by delimiter.
 */
pub
join : String -> List String -> String
join delimiter list =
  String#join(delimiter as CharSequence, List.toTypedArray CharSequence#-class (list as List CharSequence))

/**
 * Returns this string with all leading and trailing white spaces removed.
 */
pub
strip : String -> String
strip (str : String) = str#strip()

/**
 * Returns this string with all leading white spaces removed.
 */
pub
stripl : String -> String
stripl (str : String) = str#stripLeading()

/**
 * Returns this string with all trailing white spaces removed.
 */
pub
stript : String -> String
stript (str : String) = str#stripTrailing()

/**
 * Returns a string that represents the input string repeated n times.
 */
pub
repeat : Int32 -> String -> String
repeat n (str : String) = str#repeat(n)

/**
 * Returns this string with the first character converted to upper-case and the rest converted to lower-case.
 */
pub
capitalize : String -> String
capitalize (str : String) =
  case str#length() of
    0 -> str
    1 -> str#toUpperCase()
    _ ->
      let head = (toString str#charAt(0))#toUpperCase()
      let tail = str#substring(1)#toLowerCase()
      format "%s%s" [head, tail]

/**
 * Splits the string using the given regular expression.
 * Runtime: O(n)
 */
pub
split : String -> String -> List String
split regex (str : String) = str#split(regex) |> List.fromArray

/**
 * Split this string at new lines.
 */
pub
splitLines : String -> List String
splitLines (str : String) = List#"of"(str#split("""[\r|\n]+"""))

/**
 * Returns the character at the specified index if it exists.
 * Runtime: O(1)
 */
pub
nth : Int32 -> String -> Option Char
nth idx (str : String) =
  if idx >= 0 && idx < str#length()
    then Some str#charAt(idx)
    else None

/**
 * Returns the index of the given sub string inside the string
 * or -1 if none found.
 * Runtime: O(1)
 */
pub
indexOf : String -> String -> Int32
indexOf (sub : String) (str : String) = str#indexOf(sub)

/**
 * Returns a list of all chars in this string.
 * Runtime: O(n)
 */
pub
toList : String -> List Char
toList (str : String) =
  str#toCharArray() |> List.fromCharArray

/**
 * Returns a string from a list of chars.
 * Runtime: O(n)
 */
pub
fromList : List Char -> String
fromList (list : List Char) = String#new(List.toCharArray list)

/**
 * Maps a function over every char in this string.
 * Runtime: O(n)
 */
pub
map : (Char -> b) -> String -> List b
map f str = List.map f (toList str)

/**
 * Maps a function over every char in this string
 * returning a new string.
 * Runtime: O(n)
 */
pub
mapString : (Char -> Char) -> String -> String
mapString f str = map f str |> fromList

/**
 * Filters chars of this string with the given predicate.
 * Runtime: O(n)
 */
pub
filter : (Char -> Boolean) -> String -> String
filter pred str =
  toList str |> List.filter pred |> fromList

/**
 * Remove chars of this string with the given predicate.
 * Runtime: O(n)
 */
pub
remove : (Char -> Boolean) -> String -> String
remove pred str =
  toList str |> List.filter (not << pred) |> fromList

/**
 * Returns the first occurrence of a char to which the predicate returns true.
 * Runtime: O(n)
 */
pub
find : (Char -> Boolean) -> String -> Option Char
find pred str = List.find pred (toList str)

/**
 * Finds the first index in this string to which predicate returns true.
 */
pub
findIndex : (Char -> Boolean) -> String -> Int32
findIndex pred str =
  let list = toList str
  let ref = Ref#new(-1)
  forEachBreak 0L (List.size list) \idx ->
    if pred (list ! idx)
      then
        ref#-val <- (int idx)
        -1
      else 0
  ref#-val

/**
 * Drops the first n chars from this string.
 */
pub
drop : Int32 -> String -> String
drop = startFrom

/**
 * Takes the first n chars from this string.
 */
pub
take : Int32 -> String -> String
take n str = substring 0 n str

/**
 * Keeps taking chars from this string while
 * the predicate holds.
 * Runtime: O(n)
 */
pub
takeWhile : (Char -> Boolean) -> String -> String
takeWhile pred str =
  toList str
    |> List.takeWhile pred
    |> fromList

/**
 * Keeps droping chars from this string while
 * the predicate holds.
 * Runtime: O(n)
 */
pub
dropWhile : (Char -> Boolean) -> String -> String
dropWhile pred str =
  toList str
    |> List.dropWhile pred
    |> fromList

/**
 * Replaces all occurrences of old char with new.
 */
pub
replaceChar : Char -> Char -> String -> String
replaceChar old new (str : String) = str#replace(old, new)

/**
 * Replaces all substrings of this string that matches target with the given replacement. 
 */
pub
replace : String -> String -> String -> String
replace target repl (str : String) = str#replace(target as CharSequence, repl as CharSequence)

/**
 * Returns the number of characters matching the given predicate.
 * Runtime: O(n)
 */
pub
count : (Char -> Boolean) -> String -> Int32
count pred str =
  toList str |> List.count pred |> int

/**
 * Finds the smallest common indentation of all lines in this string
 * and removes it.
 * Blank lines will be removed.
 * Does not preserve line endings.
 */
pub
stripIndent : String -> String
stripIndent str =
  let lines = splitLines str |> List.filter isNotBlank
  let indent =
    lines
      |> List.map (findIndex (\(c : Char) -> not Char#isWhitespace(c)))
      |> List.min
  
  case indent of
    None -> str
    Some num ->
      lines |> List.map (startFrom num) |> join "\n"