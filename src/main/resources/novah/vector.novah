module novah.vector

foreign import type java.util.Comparator
foreign import type java.util.stream.Stream
foreign import type io.lacuna.bifurcan.IList
foreign import type novah.Core

foreign import Vector.linear() as vecLinear
foreign import Vector.forked() as vecForked
foreign import Vector.slice(Int64, Int64) as vecSlice
foreign import Vector.size() as sizeVec
foreign import Vector:"of"(Array) as fromArray
foreign import java.util.Arrays:sort(Array, Comparator) as arraySort
foreign import IList.stream() as vecStream
foreign import Core:foldVector(Function, Object, Vector)
foreign import Core:findVector(Function, Vector)

import novah.java (toComparator)
import novah.stream as S
import novah.option as O

/**
 * A linear (mutable) version of a vector.
 * Should be used in an encapsulated function to build a vector
 * avoiding the allocations of a normal vector before forking it again.
 */
pub
opaque type LinearVector a = Vector a

/**
 * Returns a stream for this vector.
 */
pub
stream : Vector a -> Stream a
stream vec = vecStream (unsafeCast vec)

/**
 * Collects this stream into a vector.
 * Runtime: O(n)
 */
pub
fromStream : Stream a -> Vector a
fromStream st =
  let lvec = vecLinear []
  S.forEach st \x -> addLast x lvec
  vecForked lvec

/**
 * Runs function f for every element of this vector, ignoring the result.
 * Runtime: O(n)
 */
pub
forEach : Vector a -> (a -> b) -> Unit
forEach vec f = forEachRange 0L (sizeVec vec) \idx -> f (vec ! idx)

/**
 * Maps function f over all elements of this vector
 * returning a vector of the same size.
 * Runtime: O(n)
 */
pub
map : (a -> b) -> Vector a -> Vector b
map f vec =
  let lvec = vecLinear []
  forEachRange 0L (sizeVec vec) \idx ->
    addLast (f (vec ! idx)) lvec
  vecForked lvec

/**
 * Returns some value at index for this vector if it exists or none.
 * This is a safe version of !
 * Runtime: ~O(1)
 */
pub
nth : Int64 -> Vector a -> Option a
nth index vec =
  let len = sizeVec vec
  if index < 0L || index >= len
  then None
  else Some (vec ! index)

/**
 * Returns the size of this vector.
 * Runtime: O(1)
 */
pub
size : Vector a -> Int64
size vec = sizeVec vec

/**
 * Returns the first element of this vector if it's not empty.
 * Runtime: ~O(1)
 */
pub
first : Vector a -> Option a
first vec = nth 0L vec

/**
 * Returns the last element of this vector if it's not empty.
 * Runtime: ~O(1)
 */
pub
last : Vector a -> Option a
last vec = nth (sizeVec vec - 1L) vec

/**
 * Returns true if this vector is empty.
 * Runtime: O(1)
 */
pub
isEmpty : Vector a -> Boolean
isEmpty vec = sizeVec vec == 0L

/**
 * Returns true if this vector is not empty.
 * Runtime: O(1)
 */
pub
isNotEmpty : Vector a -> Boolean
isNotEmpty vec = sizeVec vec != 0L

/**
 * Returns a vector of the elements that match the given predicate.
 * Runtime: O(n)
 */
pub
filter : (a -> Boolean) -> Vector a -> Vector a
filter f vec =
  let lvec = vecLinear []
  forEachRange 0L (sizeVec vec) \idx ->
    let elem = vec ! idx
    when (f elem) \_ ->
      addLast elem lvec
  vecForked lvec

/**
 * Returns the first occurrence of elem in this vector for which the predicate returns true.
 * Runtime: O(n)
 */
pub
find : (a -> Boolean) -> Vector a -> Option a
find pred vec = findVector pred vec |> O.fromOptional

/**
 * Sorts this vector according to the elements Ord instance.
 */
pub
sort : {{ Ord a }} -> Vector a -> Vector a
sort {{ord}} = case _ of
  [] -> []
  [_] as vec -> vec
  vec ->
    let arr = arrayOf vec
    let comp = toComparator ord
    arraySort arr (unsafeCast comp)
    fromArray arr

/**
 * An alias to `addFirst`.
 * Should be used when using this vector as a stack/linked list.
 * Runtime: ~O(1)
 */
pub
push : a -> Vector a -> Vector a
push = addFirst

/**
 * An alias to `removeFirst`.
 * Should be used when using this vector as a stack/linked list.
 * Runtime: ~O(1)
 */
pub
pop : Vector a -> Vector a
pop = removeFirst

/**
 * Returns true if the element is inside the vector.
 * Runtime: O(n)
 */
pub
contains : {{ Equals a }} -> a -> Vector a -> Boolean
contains {{Equals eq}} elem vec = case find (\e -> eq.equals e elem) vec of
  Some _ -> true
  None -> false

/**
 * Returns the tail of this vector if it's not empty.
 * Runtime: ~O(1)
 */
pub
tail : Vector a -> Option (Vector a)
tail = case _ of
  [] -> None
  [_ :: xs] -> Some xs

/**
 * Returns a slice of this vector starting at from (inclusive)
 * and ending at to (exclusive).
 * Runtime: ~O(1)
 */
pub
slice : Int64 -> Int64 -> Vector a -> Vector a
slice from to vec = vecSlice vec from to

/**
 * Takes the first n elements of this vector and returns it.
 * Runtime: ~O(1)
 */
pub
take : Int64 -> Vector a -> Vector a
take n = slice 0L n

/**
 * Drops the first n elements of this vector and returns it.
 * Runtime: ~O(1)
 */
pub
drop : Int64 -> Vector a -> Vector a
drop n vec = slice n (sizeVec vec) vec

/**
 * Keeps taking elements of this vector while the predicate holds.
 * Runtime: O(n)
 */
pub
takeWhile : (a -> Boolean) -> Vector a -> Vector a
takeWhile pred vec =
  let v = vecLinear vec
  let res = vecLinear []
  while isNotEmpty v && pred (v ! 0L) do
    addLast (v ! 0L) res
    removeFirst v
  vecForked res

/**
 * Keeps removing elements from this vector while the predicate holds.
 * Runtime: O(n)
 */
pub
dropWhile : (a -> Boolean) -> Vector a -> Vector a
dropWhile pred vec =
  let v = vecLinear vec
  while isNotEmpty v && pred (v ! 0L) do
    removeFirst v
  vecForked v

/**
 * Reduces this vector to a single value according to the reducing function.
 * Goes from the left to the right.
 * Runtime: O(n)
 */
pub
foldl : (b -> a -> b) -> b -> Vector a -> b
foldl f init vec = foldVector f init vec

/**
 * A specialized version of `foldl` where the first element of the vector is used as initial value.
 * Returns none if the vector is empty
 * Runtime: O(n)
 */
pub
reduce : (a -> a -> a) -> Vector a -> Option a
reduce f = case _ of
  [] -> None
  [x :: xs] -> Some (foldl f x xs)

/**
 * Reduces this vector to a single value according to the reducing function.
 * Goes from the right to the left.
 * Runtime: O(n)
 */
pub
foldr : (a -> b -> b) -> b -> Vector a -> b
foldr f init = foldl (flip f) init << reverse

/**
 * Flattens a vector of vectors into a single vector by concatenating them together.
 * Runtime: O(n)
 */
pub
flatten : Vector (Vector a) -> Vector a
flatten = case _ of
  [] -> []
  [x :: xs] -> foldl (\v1 v2 -> v1 ++ v2) x xs

/**
 * Like map, but the mapping function should return a vector.
 * Flattens the result.
 * Runtime: O(n)
 */
pub
flatMap : (a -> Vector b) -> Vector a -> Vector b
flatMap f vec = flatten (map f vec)

/**
 * Returns a reversed version of this vector.
 * Runtime: O(n)
 */
pub
reverse : Vector a -> Vector a
reverse vec =
  let lvec = vecLinear []
  forEachRange 0L (sizeVec vec) \i ->
    addFirst (vec ! i) lvec
  vecForked lvec

/**
 * Creates a linear vector out of this vector.
 */
pub
linear : Vector a -> LinearVector a
linear vec = LinearVector (vecLinear vec)

/**
 * Forks this linear vector into a vector.
 */
pub
forked : LinearVector a -> Vector a
forked (LinearVector vec) = vecForked vec

/**
 * Creates a linear (mutable) version of the given vector and applies the function to it.
 * Returns a forked (persistent) version of the returned linear vector.
 * This function should be used when lots of expensive mutating operations have to be run on a vector
 * and can be seen as a builder for the resulting vector.
 */
pub
withLinear : Vector a -> (LinearVector a -> LinearVector a) -> Vector a
withLinear vec f = linear vec |> f |> forked

/**
 * Appends x to the beginning of this vector, mutating it.
 * Runtime: ~O(1)
 */
pub
addFirstLinear : a -> LinearVector a -> LinearVector a
addFirstLinear x ((LinearVector vec) as lvec) =
  addFirst x vec
  lvec

/**
 * Appends x to the end of this vector, mutating it.
 * Runtime: ~O(1)
 */
pub
addLastLinear : a -> LinearVector a -> LinearVector a
addLastLinear x ((LinearVector vec) as lvec) =
  addLast x vec
  lvec

/**
 * Removes the first element of this vector, mutating it.
 * Runtime: ~O(1)
 */
pub
removeFirstLinear : LinearVector a -> LinearVector a
removeFirstLinear ((LinearVector vec) as lvec) =
  removeFirst vec
  lvec

/**
 * Removes the last element of this vector, mutating it.
 * Runtime: ~O(1)
 */
pub
removeLastLinear : LinearVector a -> LinearVector a
removeLastLinear ((LinearVector vec) as lvec) =
  removeLast vec
  lvec

/**
 * Sets the value of this vector at the specified index to x, mutating it.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: ~O(1)
 */
pub
setAtLinear : Int64 -> a -> LinearVector a -> LinearVector a
setAtLinear index x ((LinearVector vec) as lvec) =
  setAt index x vec
  lvec

/**
 * Returns the size of this linear vector.
 * Runtime: O(1)
 */
pub instance
sizeLinear : LinearVector a -> Int64
sizeLinear (LinearVector vec) = sizeVec vec