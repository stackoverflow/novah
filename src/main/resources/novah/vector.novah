module novah.vector

foreign import type java.util.Comparator
foreign import type java.util.stream.Stream
foreign import type io.lacuna.bifurcan.IList
foreign import type novah.Core

foreign import Vector.linear() as vecLinear
foreign import Vector.forked() as vecForked
foreign import Vector:"of"(Array) as fromArray
foreign import java.util.Arrays:sort(Array, Comparator) as arraySort
foreign import IList.stream() as vecStream
foreign import Core:foldVector(Function, Object, Vector)
foreign import Core:findVector(Function, Vector)

import novah.java (toComparator)
import novah.stream as S
import novah.option as O

/**
 * A linear (mutable) version of a vector.
 * Should be used in an encapsulated function to build a vector
 * avoiding the allocations of a normal vector before forking it again.
 */
pub
opaque type LinearVector a = Vector a

/**
 * Returns a stream for this vector.
 */
pub
stream : Vector a -> Stream a
stream vec = vecStream (unsafeCast vec)

/**
 * Collects this stream into a vector.
 * Runtime: O(n)
 */
pub
into : Stream a -> Vector a
into st =
  let lvec = vecLinear []
  in do
    S.forEach st \x -> addLast x lvec
    vecForked lvec

/**
 * Runs function f for every element of this vector, ignoring the result.
 * Runtime: O(n)
 */
pub
forEach : Vector a -> (a -> b) -> Unit
forEach vec f = forEachRange 0L (count vec) \idx ->
  f (vec ! idx)

/**
 * Maps function f over all elements of this vector
 * returning a vector of the same size.
 * Runtime: O(n)
 */
pub
map : (a -> b) -> Vector a -> Vector b
map f vec =
  let lvec = vecLinear []
  in do
    forEachRange 0L (count vec) \idx ->
      addLast (f (vec ! idx)) lvec
    vecForked lvec

/**
 * Returns some value at index for this vector if it exists or none.
 * This is a safe version of !
 * Runtime: ~O(1)
 */
pub
nth : Int64 -> Vector a -> Option a
nth index vec =
  let size = count vec
  in if index < 0L || index >= size
     then None
     else Some (vec ! index)

/**
 * Returns the first element of this vector if it's not empty.
 */
pub
first : Vector a -> Option a
first vec = nth 0L vec

/**
 * Returns the last element of this vector if it's not empty.
 */
pub
last : Vector a -> Option a
last vec = nth (count vec - 1L) vec

/**
 * Returns true if this vector is empty.
 */
pub
isEmpty : Vector a -> Boolean
isEmpty vec = count vec == 0L

/**
 * Returns a vector of the elements that match the given predicate.
 */
pub
filter : (a -> Boolean) -> Vector a -> Vector a
filter f vec =
  let lvec = vecLinear []
  in do
    forEachRange 0L (count vec) \idx ->
      let elem = vec ! idx
      in when (f elem) \_ ->
        addLast elem lvec
    vecForked lvec

/**
 * Returns the first occurrence of elem in the vector for which the predicate returns true.
 * Runtime: O(n)
 */
pub
find : (a -> Boolean) -> Vector a -> Option a
find pred vec = findVector pred vec |> O.fromOptional

/**
 * Sorts this vector according to the elements Ord instance.
 */
pub
sort : {{ Ord a }} -> Vector a -> Vector a
sort {{ord}} = case _ of
  [] -> []
  [_] as vec -> vec
  vec -> do
    let arr = arrayOf vec
    let comp = toComparator ord
    arraySort arr (unsafeCast comp)
    fromArray arr

/**
 * An alias to `addFirst`.
 * Should be used when using this vector as a stack/linked list.
 */
pub
push : a -> Vector a -> Vector a
push = addFirst

/**
 * An alias to `removeFirst`.
 * Should be used when using this vector as a stack/linked list.
 */
pub
pop : Vector a -> Vector a
pop = removeFirst

/**
 * Returns true if the element is inside the vector.
 * Runtime: O(n)
 */
pub
contains : {{ Equals a }} -> a -> Vector a -> Boolean
contains {{Equals eq}} elem vec = case find (\e -> eq.equals e elem) vec of
  Some _ -> true
  None -> false

/**
 * Reduces this vector to a single value according to the reducing function.
 * Goes from the left to the right.
 * Runtime: O(n)
 */
pub
foldl : (b -> a -> b) -> b -> Vector a -> b
foldl f init vec = foldVector f init vec

/**
 * A specialized version of `foldl` where the first element of the vector is used as initial value.
 * Returns none if the vector is empty
 * Runtime: O(n)
 */
pub
reduce : (a -> a -> a) -> Vector a -> Option a
reduce f = case _ of
  [] -> None
  [x :: xs] -> Some (foldl f x xs)

/**
 * Reduces this vector to a single value according to the reducing function.
 * Goes from the right to the left.
 * Runtime: O(n)
 */
pub
foldr : (a -> b -> b) -> b -> Vector a -> b
foldr f init = foldl (flip f) init << reverse

/**
 * Creates a linear vector out of this vector.
 */
pub
linear : Vector a -> LinearVector a
linear vec = LinearVector (vecLinear vec)

/**
 * Forks this linear vector into a vector.
 */
pub
forked : LinearVector a -> Vector a
forked (LinearVector vec) = vecForked vec

/**
 * Creates a linear (mutable) version of the given vector and applies the function to it.
 * Returns a forked (persistent) version of the returned linear vector.
 * This function should be used when lots of expensive mutating operations have to be run on a vector
 * and can be seen as a builder for the resulting vector.
 */
pub
withLinear : Vector a -> (LinearVector a -> LinearVector a) -> Vector a
withLinear vec f = linear vec |> f |> forked

/**
 * Appends x to the beginning of this vector, mutating it.
 * Runtime: ~O(1)
 */
pub
addFirstLinear : a -> LinearVector a -> LinearVector a
addFirstLinear x ((LinearVector vec) as lvec) = do
  addFirst x vec
  lvec

/**
 * Appends x to the end of this vector, mutating it.
 * Runtime: ~O(1)
 */
pub
addLastLinear : a -> LinearVector a -> LinearVector a
addLastLinear x ((LinearVector vec) as lvec) = do
  addLast x vec
  lvec

/**
 * Removes the first element of this vector, mutating it.
 * Runtime: ~O(1)
 */
pub
removeFirstLinear : LinearVector a -> LinearVector a
removeFirstLinear ((LinearVector vec) as lvec) = do
  removeFirst vec
  lvec

/**
 * Removes the last element of this vector, mutating it.
 * Runtime: ~O(1)
 */
pub
removeLastLinear : LinearVector a -> LinearVector a
removeLastLinear ((LinearVector vec) as lvec) = do
  removeLast vec
  lvec

/**
 * Sets the value of this vector at the specified index to x, mutating it.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: ~O(1)
 */
pub
setAtLinear : Int64 -> a -> LinearVector a -> LinearVector a
setAtLinear index x ((LinearVector vec) as lvec) = do
  setAt index x vec
  lvec

pub instance
countLinearVector : Count (LinearVector a)
countLinearVector = Count { count: \(LinearVector v) -> count v }

/**
 * Returns a reversed version of this vector.
 * Runtime: O(n)
 */
pub
reverse : Vector a -> Vector a
reverse vec = do
  let lvec = vecLinear []
  forEachRange 0L (count vec) \i ->
    addFirst (vec ! i) lvec
  vecForked lvec