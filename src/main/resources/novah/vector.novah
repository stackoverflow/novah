module novah.vector

foreign import type java.util.Comparator
foreign import type java.util.stream.Stream
foreign import type io.lacuna.bifurcan.IList
foreign import type novah.Core

foreign import Vector.linear() as vecLinear
foreign import Vector.forked() as vecForked
foreign import Vector.slice(Int64, Int64) as vecSlice
foreign import Vector.size() as sizeVec
foreign import Vector:"of"(Array) as vecFromArray
foreign import java.util.Arrays:sort(Array, Comparator) as arraySort
foreign import IList.stream() as vecStream
foreign import IList.toArray() as vecToArray
foreign import Core:foldVector(Function, Object, Vector)
foreign import Core:findVector(Function, Vector)

import novah.java (toComparator)
import novah.stream as S
import novah.option as O

/**
 * Returns a stream for this vector.
 */
pub
stream : Vector a -> Stream a
stream vec = vecStream (unsafeCast vec)

/**
 * Collects this stream into a vector.
 * Runtime: O(n)
 */
pub
fromStream : Stream a -> Vector a
fromStream st =
  let lvec = vecLinear []
  S.forEach st \x -> addLast x lvec
  vecForked lvec

/**
 * Runs function f for every element of this vector, ignoring the result.
 * Runtime: O(n)
 */
pub
forEach : Vector a -> (a -> b) -> Unit
forEach vec f = forEachRange 0L (sizeVec vec) \idx -> f (vec ! idx)

/**
 * Maps function f over all elements of this vector
 * returning a vector of the same size.
 * Runtime: O(n)
 */
pub
map : (a -> b) -> Vector a -> Vector b
map f vec =
  let lvec = vecLinear []
  forEachRange 0L (sizeVec vec) \idx ->
    addLast (f (vec ! idx)) lvec
  vecForked lvec

/**
 * Returns some value at index for this vector if it exists or none.
 * This is a safe version of !
 * Runtime: ~O(1)
 */
pub
nth : Int64 -> Vector a -> Option a
nth index vec =
  let len = sizeVec vec
  if index < 0L || index >= len
  then None
  else Some (vec ! index)

/**
 * Returns the size of this vector.
 * Runtime: O(1)
 */
pub
size : Vector a -> Int64
size vec = sizeVec vec

/**
 * Returns the first element of this vector if it's not empty.
 * Runtime: ~O(1)
 */
pub
first : Vector a -> Option a
first vec = nth 0L vec

/**
 * Returns the last element of this vector if it's not empty.
 * Runtime: ~O(1)
 */
pub
last : Vector a -> Option a
last vec = nth (sizeVec vec - 1L) vec

/**
 * Returns true if this vector is empty.
 * Runtime: O(1)
 */
pub
isEmpty : Vector a -> Boolean
isEmpty vec = sizeVec vec == 0L

/**
 * Returns true if this vector is not empty.
 * Runtime: O(1)
 */
pub
isNotEmpty : Vector a -> Boolean
isNotEmpty vec = sizeVec vec != 0L

/**
 * Returns a vector of the elements that match the given predicate.
 * Runtime: O(n)
 */
pub
filter : (a -> Boolean) -> Vector a -> Vector a
filter f vec =
  let lvec = vecLinear []
  forEachRange 0L (sizeVec vec) \idx ->
    let elem = vec ! idx
    when (f elem) \_ ->
      addLast elem lvec
  vecForked lvec

/**
 * Returns the first occurrence of elem in this vector for which the predicate returns true.
 * Runtime: O(n)
 */
pub
find : (a -> Boolean) -> Vector a -> Option a
find pred vec = findVector pred vec |> O.fromOptional

/**
 * Sorts this vector according to the comparing function.
 */
pub
sortBy : (a -> a -> Ordering) -> Vector a -> Vector a
sortBy cmp = case _ of
  [] -> []
  [_] as vec -> vec
  vec ->
    let arr = toArray vec
    let comp = toComparator cmp
    arraySort arr (unsafeCast comp)
    vecFromArray arr

/**
 * Sorts this vector according to the element's Ord instance.
 */
pub
sort : {{ Ord a }} -> Vector a -> Vector a
sort {{Ord _ ord}} = sortBy ord.compare

/**
 * An alias to `addFirst`.
 * Should be used when using this vector as a stack/linked list.
 * Runtime: ~O(1)
 */
pub
push : a -> Vector a -> Vector a
push = addFirst

/**
 * An alias to `removeFirst`.
 * Should be used when using this vector as a stack/linked list.
 * Runtime: ~O(1)
 */
pub
pop : Vector a -> Vector a
pop = removeFirst

/**
 * Returns true if the element is inside the vector.
 * Runtime: O(n)
 */
pub
contains : {{ Equals a }} -> a -> Vector a -> Boolean
contains {{Equals eq}} elem vec = case find (\e -> eq.equals e elem) vec of
  Some _ -> true
  None -> false

/**
 * Returns the tail of this vector if it's not empty.
 * Runtime: ~O(1)
 */
pub
tail : Vector a -> Option (Vector a)
tail = case _ of
  [] -> None
  [_ :: xs] -> Some xs

/**
 * Returns a slice of this vector starting at from (inclusive)
 * and ending at to (exclusive).
 * Runtime: ~O(1)
 */
pub
slice : Int64 -> Int64 -> Vector a -> Vector a
slice from to vec = vecSlice vec from to

/**
 * Takes the first n elements of this vector and returns it.
 * Runtime: ~O(1)
 */
pub
take : Int64 -> Vector a -> Vector a
take n = slice 0L n

/**
 * Drops the first n elements of this vector and returns it.
 * Runtime: ~O(1)
 */
pub
drop : Int64 -> Vector a -> Vector a
drop n vec = slice n (sizeVec vec) vec

/**
 * Keeps taking elements of this vector while the predicate holds.
 * Runtime: O(n)
 */
pub
takeWhile : (a -> Boolean) -> Vector a -> Vector a
takeWhile pred vec =
  let v = vecLinear vec
  let res = vecLinear []
  while isNotEmpty v && pred (v ! 0L) do
    addLast (v ! 0L) res
    removeFirst v
  vecForked res

/**
 * Keeps removing elements from this vector while the predicate holds.
 * Runtime: O(n)
 */
pub
dropWhile : (a -> Boolean) -> Vector a -> Vector a
dropWhile pred vec =
  let v = vecLinear vec
  while isNotEmpty v && pred (v ! 0L) do
    removeFirst v
  vecForked v

/**
 * Reduces this vector to a single value according to the reducing function.
 * Goes from the left to the right.
 * Runtime: O(n)
 */
pub
foldl : (b -> a -> b) -> b -> Vector a -> b
foldl f init vec = foldVector f init vec

/**
 * A specialized version of `foldl` where the first element of the vector is used as initial value.
 * Returns none if the vector is empty
 * Runtime: O(n)
 */
pub
reduce : (a -> a -> a) -> Vector a -> Option a
reduce f = case _ of
  [] -> None
  [x :: xs] -> Some (foldl f x xs)

/**
 * Reduces this vector to a single value according to the reducing function.
 * Goes from the right to the left.
 * Runtime: O(n)
 */
pub
foldr : (a -> b -> b) -> b -> Vector a -> b
foldr f init = foldl (flip f) init << reverse

/**
 * Flattens a vector of vectors into a single vector by concatenating them together.
 * Runtime: O(n)
 */
pub
flatten : Vector (Vector a) -> Vector a
flatten = case _ of
  [] -> []
  [x :: xs] -> foldl (\v1 v2 -> v1 ++ v2) x xs

/**
 * Like map, but the mapping function should return a vector.
 * Flattens the result.
 * Runtime: O(n)
 */
pub
flatMap : (a -> Vector b) -> Vector a -> Vector b
flatMap f vec = flatten (map f vec)

/**
 * Returns a reversed version of this vector.
 * Runtime: O(n)
 */
pub
reverse : Vector a -> Vector a
reverse vec =
  let lvec = vecLinear []
  forEachRange 0L (sizeVec vec) \i ->
    addFirst (vec ! i) lvec
  vecForked lvec

/**
 * Converts this vector into an array.
 * Runtime: O(n)
 */
pub
toArray : Vector a -> Array a
toArray vec = unsafeCast (vecToArray (unsafeCast vec))

/**
 * Converts this array into a vector.
 * Runtime: O(n)
 */
pub
fromArray : Array a -> Vector a
fromArray arr = vecFromArray arr

/**
 * Creates a linear (mutable) version of the given vector and applies the function to it.
 * Returns a forked (persistent) version of the returned linear vector.
 * This function should be used when lots of expensive mutating operations have to be run on a vector
 * and can be seen as a builder for the resulting vector.
 * All functions that alter vectors like `addFirst`, `setAt`, `removeLast`, etc.
 * will mutate a linear vector.
 * Ex:
 *   withLinear [1, 2, 3] \vec ->
 *     addFirst 0 vec
 *     addLast 4 vec
 *
 *   -> [0, 1, 2, 3, 4]
 */
pub
withLinear : Vector a -> (Vector a -> Vector a) -> Vector a
withLinear vec f = vecForked (f (vecLinear vec))