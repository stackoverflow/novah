module novah.set

foreign import type java.util.stream.Stream
foreign import type java.util.OptionalLong
foreign import type java.util.function.BiPredicate
foreign import type java.util.function.ToLongFunction
foreign import type io.lacuna.bifurcan.ISet
foreign import type novah.Core

foreign import get io.lacuna.bifurcan.Maps:DEFAULT_HASH_CODE as defaultHashCode
foreign import ISet.stream() as setStream
foreign import new Set(ToLongFunction, BiPredicate) as newSet
foreign import Set.linear() as setLinear
foreign import Set.forked() as setForked
foreign import Set.add(Object) as setAdd
foreign import Set.remove(Object) as setRemove
foreign import Set.nth(Int64) as setNth
foreign import Set.contains(Object) as setContains
foreign import Set.union(ISet) as sunion
foreign import Set.difference(ISet) as sdifference
foreign import Set.intersection(ISet) as sintersection
foreign import Core:foldSet(Function, Object, Set)

import novah.stream as S
import novah.java as J
import novah.option as O

/**
 * Creates a new set which uses the element equality function and the provided hash function, or the default object hash function.
 * This function should always be used to create new sets for types that have equality implementations that differ from its own
 * `equals` function.
 * Note that Novah creates default, sensible `equals` and `hashCode` implementations for every type, so this function is only needed
 * for types where the `equals` function and the `Equals` type class implementation diverge.
 */
pub
new : {{ Equals a }} -> Option (a -> Int64) -> Set a
new {{Equals eq}} hashFn =
  let hash = O.map J.toLong hashFn ?: defaultHashCode
  in newSet hash (J.bipredicate eq.equals)

/**
 * Inserts this element in the set.
 * Runtime: ~O(1)
 */
pub
add : a -> Set a -> Set a
add x set = setAdd set x

/**
 * Removes this element from the set.
 * Runtime: ~O(1)
 */
pub
remove : a -> Set a -> Set a
remove x set = setRemove set x

/**
 * Returns true if this set is empty.
 */
pub
isEmpty : Set a -> Boolean
isEmpty set = count set == 0L

/**
 * Returns some value at index for this set if it exists or none.
 * Runtime: ~O(1)
 */
pub
nth : Int64 -> Set a -> Option a
nth index set =
  let size = count set
  in if index < 0L || index >= size
     then None
     else Some (setNth set index)

/**
 * Returns the union of these 2 sets.
 * This is the same as `set1 ++ set2`.
 */
pub
union : Set a -> Set a -> Set a
union s1 s2 = sunion s1 (unsafeCast s2)

/**
 * Returns the difference between these 2 sets.
 */
pub
difference : Set a -> Set a -> Set a
difference s1 s2 = sdifference s1 (unsafeCast s2)

/**
 * Returns the intersection between these 2 sets.
 */
pub
intersection : Set a -> Set a -> Set a
intersection s1 s2 = sintersection s1 (unsafeCast s2)

/**
 * Returns a stream for this set.
 */
pub
stream : Set a -> Stream a
stream set = setStream (unsafeCast set)

/**
 * Collects this stream into a set.
 * Runtime: O(n)
 */
pub
into : Stream a -> Set a
into st =
  let lset = setLinear #{}
  S.forEach st \x -> add x lset
  setForked lset

/**
 * Runs function f for every element of this set, ignoring the result.
 * Runtime: O(n)
 */
pub
forEach : Set a -> (a -> b) -> Unit
forEach set f =
  forEachRange 0L (count set) \idx ->
    f (setNth set idx)

/**
 * Maps function f over all elements of this set
 * returning a set of the same size.
 * Runtime: O(n)
 */
pub
map : (a -> b) -> Set a -> Set b
map f set =
  let lset = setLinear #{}
  forEachRange 0L (count set) \idx ->
    add (f (setNth set idx)) lset
  setForked lset

/**
 * Returns an array of the elements that match the given predicate.
 * Runtime: O(n)
 */
pub
filter : (a -> Boolean) -> Set a -> Set a
filter pred set =
  let lset = setLinear #{}
  forEachRange 0L (count set) \idx ->
    let elem = setNth set idx
    when (pred elem) \_ ->
      add elem lset
  setForked lset

/**
 * Returns the first occurrence of elem in the set for which the predicate returns true.
 * This function uses the set's equality function, set at creation time.
 * Runtime: ~O(1)
 */
pub
find : (a -> Boolean) -> Set a -> Option a
find pred set =
  let lset = setLinear #{}
  forEachBreak 0L (count set) \idx ->
    let elem = setNth set idx
    if pred elem
    then
      add elem lset
      -1
    else 0 
  nth 0L lset

/**
 * Returns true if the element is inside the set.
 * This function uses the set's equality function, set at creation time.
 * Runtime: ~O(1)
 */
pub
contains : a -> Set a -> Boolean
contains elem set = setContains set elem

/**
 * Reduces this set to a single value according to the reducing function.
 * Goes from the left to the right.
 * Runtime: O(n)
 */
pub
foldl : (b -> a -> b) -> b -> Set a -> b
foldl f init set = foldSet f init set