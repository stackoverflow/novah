// A lightweight test library.
// Test functions can be created using the `test` attribute
// and their types have to be `Unit -> Unit`.
module novah.test

import novah.java as Java
import novah.list as List
import novah.meta as Meta

foreign import java.lang.AssertionError
foreign import java.lang.Exception
foreign import java.lang.Throwable
foreign import novah.Core

// All possible results for a test suite.
pub+
type TestResult
  = Success
  | Failure
  | Error

// Executes the function for every entry in the table.
// Ex:
// ```novah
// withTable
//   [ { animal: "Cat", sound: "meow" }
//   , { animal: "Dog", sound: "woof" }
//   , { animal: "Duck", sound: "quack" }
//   ]
//   \{animal, sound} -> makeSound animal `shouldBe` sound
// ```
pub
withTable : List { | r } -> ({ | r } -> Unit) -> Unit
withTable = List.forEach

// Fails the test if x is not equals y.
pub
shouldBe : {{ Equals a }} -> a -> a -> Unit
shouldBe {{_}} x y =
  if x != y then
    throw AssertionError#new(format "`%s` is not equals `%s`" [x, y] as Object)

// Fails the test if x is equals y.
pub
shouldNotBe : {{ Equals a }} -> a -> a -> Unit
shouldNotBe {{_}} x y =
  if x == y then
    throw AssertionError#new(format "`%s` is equals `%s`" [x, y] as Object)

// Fails the test if the record r1 is not equals r2.
pub
recordShouldBe : {  | r } -> {  | r } -> Unit
recordShouldBe r1 r2 =
  if not (recordEquals r1 r2) then
    throw AssertionError#new(format "%s is not equals %s" [r1, r2] as Object)

// Fails the test if the record r1 is equals r2.
pub
recordShouldNotBe : {  | r } -> {  | r } -> Unit
recordShouldNotBe r1 r2 =
  if recordEquals r1 r2 then
    throw AssertionError#new(format "%s is equals %s" [r1, r2] as Object)

// Fails the test if the element is not inside the container.
pub
shouldBeIn : {{ Contained a b }} -> a -> b -> Unit
shouldBeIn {{_}} x box =
  if x !in box then
    throw AssertionError#new(format "%s is not inside %s" [toString x, toString box] as Object)

// Fails the test if the element is inside the container.
pub
shouldNotBeIn : {{ Contained a b }} -> a -> b -> Unit
shouldNotBeIn {{_}} x box =
  if x in box then
    throw AssertionError#new(format "%s is inside %s" [toString x, toString box] as Object)

// Fails the test if some element of the list is not inside the container.
pub
shouldAllBeIn : {{ Contained a b }} -> List a -> b -> Unit
shouldAllBeIn {{_}} list set =
  List.forEach list \x ->
    if x !in set then
      throw AssertionError#new(format "%s is not inside %s" [toString x, toString set] as Object)

// Fails the test if this option is empty.
pub
shouldBeSome : Option a -> Unit
shouldBeSome opt = case opt of
  Some _ -> ()
  None -> throw AssertionError#new(format "%s is not Some" [opt] as Object)

// Fails the test if this option is not empty.
pub
shouldBeNone : Option a -> Unit
shouldBeNone opt = case opt of
  Some _ -> throw AssertionError#new(format "%s is not None" [opt] as Object)
  None -> ()

// Fails the test if this list is not empty.
pub
shouldBeEmpty : List a -> Unit
shouldBeEmpty list = case list of
  [] -> ()
  _ -> throw AssertionError#new(format "list %s is not empty" [list] as Object)

// Fails the test if this list is empty.
pub
shouldNotBeEmpty : List a -> Unit
shouldNotBeEmpty list = case list of
  [] -> throw AssertionError#new("list is empty" as Object)
  _ -> ()

innerRunTests : (Unit -> Unit) -> (Unit -> Unit) -> TestResult
innerRunTests before after =
  let tests = Meta.findTests ()
  let total = atom 0
  let stats = List.toTypedArray Int#-class [0, 0, 0]
  let addStats v =
    aupdate 0 (_ + v.[0]) stats
    aupdate 1 (_ + v.[1]) stats
    aupdate 2 (_ + v.[2]) stats

  List.forEach tests \{decl, desc, function} ->
    before ()
    swap (_ + 1) total
    check (if desc == "" then decl else desc) function |> addStats
    after ()

  let failures = aget 1 stats
  let errors = aget 2 stats
  println "\nSummary"
  printfln "%s/%s tests passed" [aget 0 stats, @total]
  printfln "%d failures" [failures]
  printfln "%d errors" [errors]

  case failures, errors of
    0, 0 -> Success
    _, 0 -> Failure
    _, _ -> Error

// Run all registered tests.
// Tests need to be located in a root `test` package.
pub
runTests : Unit -> TestResult
runTests _ =
  Core#loadAllClasses("test")
  innerRunTests identity identity

// Run all registered tests.
// Tests need to be located in a root `test` package.
// The two given functions will be run before and
// after every test.
pub
runTestsWith : (Unit -> Unit) -> (Unit -> Unit) -> TestResult
runTestsWith before after =
  Core#loadAllClasses("test")
  innerRunTests before after

// Run all registered tests.
// Modules containing tests will be searched
// in the given root package.
pub
runTestsFor : String -> TestResult
runTestsFor package =
  Core#loadAllClasses(package)
  innerRunTests identity identity

// Run all registered tests.
// Modules containing tests will be searched
// in the given root package.
// The two given functions will be run before and
// after every test.
pub
runTestsForWith : String -> (Unit -> Unit) -> (Unit -> Unit) -> TestResult
runTestsForWith package before after =
  Core#loadAllClasses(package)
  innerRunTests before after

// Exits the JVM.
// The exit status will depend on the test results:
// Success: 0
// Failure: 1
// Error: 2
pub
exit : TestResult -> Unit
exit = case _ of
  Success -> Java.exit 0
  Failure -> Java.exit 1
  Error -> Java.exit 2

check : String -> (Unit -> Unit) -> List Int
check desc fun =
  try
    println ""
    fun ()
    printfln "âœ“ %s" [desc]
    [1, 0, 0]
  catch
    :? AssertionError as err ->
      printlnErr (format "Failure in test: %s" [desc])
      (err as Throwable)#printStackTrace()
      [0, 1, 0]
    :? Exception as err ->
      printlnErr (format "Error in test: %s" [desc])
      (err as Throwable)#printStackTrace()
      [0, 0, 1]