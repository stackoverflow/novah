module novah.map

foreign import io.lacuna.bifurcan.Map
foreign import io.lacuna.bifurcan.Maps
foreign import io.lacuna.bifurcan.IMap
foreign import io.lacuna.bifurcan.IEntry
foreign import novah.Core

import novah.java as Java
import novah.option as Option
import novah.list as List

/**
 * Creates a new map with the supplied entries.
 */
pub
new : List (Tuple k v) -> Map k v
new list =
  let lmap = Map#empty()#linear()
  List.forEach list \(Tuple key val) -> put key val lmap
  lmap#forked()

/**
 * Creates a new map which uses the key equality function and the provided hash function, or the default object hash function.
 * This function should always be used to create new maps for types that have equality implementations that differ from its own
 * `equals` function.
 * Note that Novah creates default, sensible `equals` and `hashCode` implementations for every type.
 */
pub
newEq : {{ Equals k }} -> Option (k -> Int64) -> Map k v
newEq {{Equals eq}} hashFn =
  let hash = Option.map Java.toLong hashFn ?: Maps#-"DEFAULT_HASH_CODE"
  Map#new(hash, Java.bipredicate eq.equals)

/**
 * Returns the size of the map.
 * Runtime: O(1)
 */
pub
size : Map k v -> Int64
size (m : Map k v) = m#size()

/**
 * Inserts or replaces a new key/value pair in the map.
 * Runtime: ~O(1)
 */
pub
put : k -> v -> Map k v -> Map k v
put key val map = (map as IMap k v)#put(key, val) as Map k v

/**
 * Returns the value under key if it exists.
 * Runtime: ~O(1)
 */
pub
get : k -> Map k v -> Option v
get k map = (map as IMap k v)#get(k) |> Option.fromOptional

/**
 * Applies the function to the value represented by the key, updating it.
 * Runtime: ~O(1)
 */
pub
update : k -> (v -> v) -> Map k v -> Map k v
update key fun (map : Map k v) = map#update(key, Java.unaryOperator fun)

/**
 * Removes the key from this map.
 * Runtime: ~O(1)
 */
pub
remove : k -> Map k v -> Map k v
remove key (map : Map k v) = map#remove(key)

/**
 * Returns true if this map contains the key.
 * Runtime: ~O(1)
 */
pub
hasKey : k -> Map k v -> Boolean
hasKey key (map : Map k v) = map#contains(key)

/**
 * Returns the result of merging the two maps.
 * Repeated keys in the second map will overwrite keys from the first.
 * An alias for `++`.
 */
pub
merge : Map k v -> Map k v -> Map k v
merge (m1 : Map k v) m2 = m1#union(m2 as IMap k v)

/**
 * Returns a set of all keys in this map.
 * Runtime: O(1)
 */
pub
keys : Map k v -> Set k
keys (map : Map k v) = map#keys()

/**
 * Returns a list of all values in this map.
 */
pub
values : Map k v -> List v
values (map : Map k v) = List#from(map#values())

/**
 * Executes the function for every key/value pair in this map
 * Runtime: O(n)
 */
pub
forEach : Map k v -> (k -> v -> Unit) -> Unit
forEach (map : Map k v) f =
  Java.forEach map#iterator() \(entry : IEntry k v) -> f entry#key() entry#value()

/**
 * Maps function f over all entries of this map.
 * Runtime: O(n)
 */
pub
mapValues : (k -> v -> v2) -> Map k v -> Map k v2
mapValues f (map : Map k v) = map#mapValues(Java.biFunction f)

/**
 * Returns a map of the elements that match the given predicate.
 * Runtime: O(n)
 */
pub
filter : (k -> v -> Boolean) -> Map k v -> Map k v
filter pred (map : Map k v) =
  let lmap = map#linear()
  forEach lmap \k v ->
    when (not (pred k v)) \_ -> lmap#remove(k)
  lmap#forked()

/**
 * Returns true if the predicate is true for every entry in this map.
 * Runtime: O(n)
 */
pub
every : (k -> v -> Boolean) -> Map k v -> Boolean
every pred map = Core#mapEvery(pred, map)

pub instance
concatMap : Concat (Map k v)
concatMap = Concat { concat: merge }

pub instance
eqMap : {{ Equals k }} -> {{ Equals v }} -> Equals (Map k v)
eqMap {{Equals eqk}} {{Equals eqv}} = Equals { equals: \x y -> Core#equalsMap(x, y, eqk.equals, eqv.equals) }

/**
 * Creates a linear (mutable) version of the given map and applies the function to it.
 * Returns a forked (persistent) version of the returned linear map.
 * This function should be used when lots of expensive mutating operations have to be run on a map
 * and can be seen as a builder for the resulting map.
 * All functions that alter maps like `put`, `update`, `remove`, etc.
 * will mutate a linear map.
 * Ex:
 *   withLinear (Map.new ["a" <> 1, "b" <> 2, "c" <> 3]) \map ->
 *     put "d" 4 map
 *     remove "b" map
 *
 *   -> {"a" 1, "c" 3, "d" 4}
 */
pub
withLinear : Map k v -> (Map k v -> Map k v) -> Map k v
withLinear (map : Map k v) f =
  let lin = (f map#linear())
  (lin : Map k v)#forked()