/**
 * The core functions of the language.
 * Imported automatically in every module.
 */
module novah.core

foreign import type io.lacuna.bifurcan.IList
foreign import type io.lacuna.bifurcan.ISet
foreign import type java.util.function.Function
foreign import type novah.Core
foreign import type novah.collections.Record
foreign import type java.util.concurrent.atomic.AtomicReference

foreign import get java.lang.System:out
foreign import java.io.PrintStream.println(Object) as jprintln
foreign import java.io.PrintStream.print(Object) as jprint
foreign import Int32.longValue()
foreign import Object.toString() as jToString
foreign import Object.hashCode() as jHashCode
foreign import String:format(String, Array) as sformat
foreign import String.equals(String) as equalsString
foreign import IList.toArray() as vecToArr
foreign import Vector.concat(IList) as vecConcat
foreign import Vector.size() as sizeVec
foreign import Vector.nth(Int64) as nthVec
foreign import Vector.addFirst(Object) as addFirstVec
foreign import Vector.addLast(Object) as addLastVec
foreign import Vector.removeFirst() as remFirst
foreign import Vector.removeLast() as remLast
foreign import Vector.set(Int64, Object) as setVec
foreign import String.concat(String)
foreign import String.length() as strLength
foreign import Set.union(ISet)
foreign import Set.size() as sizeSet
foreign import Record.size() as recSize
foreign import Byte.intValue() as bToI
foreign import Int16.intValue() as sToI
foreign import Float32.doubleValue() as fToD
foreign import Char.compareTo(Char) as compareChar
foreign import new AtomicReference(Object) as newAtom
foreign import AtomicReference.get() as atomGet
foreign import AtomicReference.set(Object) as atomSet
foreign import AtomicReference.compareAndSet(Object, Object) as atomCmpAndSet

foreign import Core:not(Boolean) as negate
foreign import Core:mkByteArray(Int32)
foreign import Core:mkInt16Array(Int32)
foreign import Core:mkInt32Array(Int32)
foreign import Core:mkInt64Array(Int32)
foreign import Core:mkFloat32Array(Int32)
foreign import Core:mkFloat64Array(Int32)
foreign import Core:mkCharArray(Int32)
foreign import Core:mkBooleanArray(Int32)
foreign import Core:mkObjectArray(Int32)
foreign import Core:getArray(Int32, Array)
foreign import Core:setArray(Int32, Object, Array)
foreign import Core:getArrayLength(Array)
foreign import Core:equivalentObject(Object, Object)
foreign import Core:sum(Int32, Int32) as sumInt
foreign import Core:sum(Int64, Int64) as sumInt64
foreign import Core:sum(Float32, Float32) as sumFloat32
foreign import Core:sum(Float64, Float64) as sumFloat64
foreign import Core:sub(Int32, Int32) as subInt
foreign import Core:sub(Int64, Int64) as subInt64
foreign import Core:sub(Float32, Float32) as subFloat32
foreign import Core:sub(Float64, Float64) as subFloat64
foreign import Core:mult(Int32, Int32) as mulInt
foreign import Core:mult(Int64, Int64) as mulInt64
foreign import Core:mult(Float32, Float32) as mulFloat32
foreign import Core:mult(Float64, Float64) as mulFloat64
foreign import Core:div(Int32, Int32) as divInt
foreign import Core:div(Int64, Int64) as divInt64
foreign import Core:div(Float32, Float32) as divFloat32
foreign import Core:div(Float64, Float64) as divFloat64
foreign import Core:equivalent(Byte, Byte) as equiByte
foreign import Core:equivalent(Int16, Int16) as equiInt16
foreign import Core:equivalent(Int32, Int32) as equiInt32
foreign import Core:equivalent(Int64, Int64) as equiInt64
foreign import Core:equivalent(Float32, Float32) as equiFloat32
foreign import Core:equivalent(Float64, Float64) as equiFloat64
foreign import Core:equivalent(Char, Char) as equiChar
foreign import Core:equalsVector(Vector, Vector, Function)
foreign import Core:equalsSet(Set, Set, Function)
foreign import Core:equalsArray(Array, Array, Function)
foreign import Core:toStringVector(Vector, Function)
foreign import Core:toStringSet(Set, Function)
foreign import Core:toStringArray(Array, Function)
foreign import Core:compareInt(novah.core.Ordering, novah.core.Ordering, novah.core.Ordering)
foreign import Core:compareLong(novah.core.Ordering, novah.core.Ordering, novah.core.Ordering)
foreign import Core:compareDouble(novah.core.Ordering, novah.core.Ordering, novah.core.Ordering)
foreign import Core:compareChar(novah.core.Ordering, novah.core.Ordering, novah.core.Ordering)
foreign import Core:compareString(novah.core.Ordering, novah.core.Ordering, novah.core.Ordering)
foreign import Core:swapAtom(AtomicReference, Function)
foreign import Core:and(Boolean, Boolean)
foreign import Core:or(Boolean, Boolean)
foreign import Core:eachRange(Int64, Int64, Int32, Function)
foreign import Core:vecIntRange(Int32, Int32)
foreign import Core:vecLongRange(Int64, Int64)
foreign import Core:vecFloatRange(Float32, Float32)
foreign import Core:vecDoubleRange(Float64, Float64)
foreign import Core:vecCharRange(Char, Char)
foreign import Core:intToChar(Int32)
foreign import Core:charToInt(Char)

/**
 * A 32-bits Integer
 */
pub
typealias Int = Int32

/**
 * A 64-bits floating point.
 */
pub
typealias Float = Float64

/**
 * Coerce parameter x from type a to b.
 * This is extremely unsafe and should be used only
 * when sure both types are compatible, otherwise
 * a runtime exception will be thrown.
 */
pub
unsafeCast : a -> b
unsafeCast x = unsafeCoerce x

/**
 * Negates a boolean value.
 */
pub
not : Boolean -> Boolean
not b = negate b

/**
 * Returns its argument unmodified.
 */
pub
identity : a -> a
identity x = x

/**
 * Flips the arguments of a 2-arguments function.
 */
pub
flip : (a -> b -> c) -> (b -> a -> c)
flip f y x = f x y

/**
 * Takes two parameters and returns the first, ignoring the second.
 */
pub
const : a -> b -> a
const x _ = x

/**
 * Apply function f to x.
 * Used to minimize parentheses and have a
 * more intuitive order of execution:
 *
 * x |> fun1 |> fun2 |> fun3 y
 * instead of
 * fun3 y (fun2 (fun1 x))
 */
pub
(|>) : a -> (a -> b) -> b
(|>) x f = f x

/**
 * Forward function composition operator: (f >> g) x = g (f x)
 */
pub
(>>) : (a -> b) -> (b -> c) -> (a -> c)
(>>) f g x = g (f x)

/**
 * Backward function composition operator: (f << g) x = f (g x)
 */
pub
(<<) : (b -> c) -> (a -> b) -> (a -> c)
(<<) f g x = f (g x)

/**
 * Returns true if the 2 objects point to the same object.
 * This is the same as Java's ==
 */
pub
(===) : a -> a -> Boolean
(===) x y = equivalentObject (unsafeCast x) (unsafeCast y)

/**
 * Returns true if the 2 objects *do not* point to the same object.
 * This is the same as Java's !=
 */
pub
(!==) : a -> a -> Boolean
(!==) x y = negate (x === y)

/**
 * Logical `and` operator.
 * Returns true if both conditions are true.
 * This operator will short circuit if fully applied.
 */
pub
(&&) : Boolean -> Boolean -> Boolean
(&&) cond1 cond2 = and cond1 cond2

/**
 * Logical `or` operator.
 * Returns true if at least one of the conditions is true.
 * This operator will short circuit if fully applied.
 */
pub
(||) : Boolean -> Boolean -> Boolean
(||) cond1 cond2 = or cond1 cond2

/**
 * Prints x to stdout and appends a new line.
 */
pub
println : a -> Unit
println x = jprintln out (unsafeCast x)

/**
 * Prints x to the stdout.
 */
pub
print : a -> Unit
print x = jprint out (unsafeCast x)

/**
 * Converts a value to String using the
 * native Java toString method.
 */
pub
toString : a -> String
toString x = jToString (unsafeCast x)

/**
 * Returns the hash code for this value using
 * the native Java hashCode method.
 */
pub
hashCode : a -> Int32
hashCode x = jHashCode (unsafeCast x)

/**
 * Converts this 32-bit integer to a 64-bit integer.
 */
pub
int64 : Int32 -> Int64
int64 i = longValue i

/**
 * Returns the value at index for this Vector.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: ~O(1)
 */
pub
(!) : Vector a -> Int64 -> a
(!) vec index = unsafeCast (nthVec (unsafeCast vec) index)

/**
 * Sets the value of this vector at the specified index to x.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: ~O(1)
 */
pub
setAt : Int64 -> a -> Vector a -> Vector a
setAt index x vec = unsafeCast (setVec (unsafeCast vec) index (unsafeCast x))

/**
 * Updates the value of this vector at the specified index by applying function f to the old value.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: ~O(1)
 */
pub
updateAt : Int64 -> (a -> a) -> Vector a -> Vector a
updateAt index f vec = setAt index (f (vec ! index)) vec

/**
 * Appends x to the beginning of this vector.
 * Runtime: ~O(1)
 */
pub
addFirst : a -> Vector a -> Vector a
addFirst x vec = unsafeCast (addFirstVec (unsafeCast vec) (unsafeCast x))

/**
 * Appends x to the end of this vector.
 * Runtime: ~O(1)
 */
pub
addLast : a -> Vector a -> Vector a
addLast x vec = unsafeCast (addLastVec (unsafeCast vec) (unsafeCast x))

/**
 * Removes the first element of this vector.
 * Runtime: ~O(1)
 */
pub
removeFirst : Vector a -> Vector a
removeFirst vec = unsafeCast (remFirst (unsafeCast vec))

/**
 * Removes the last element of this vector.
 * Runtime: ~O(1)
 */
pub
removeLast : Vector a -> Vector a
removeLast vec = unsafeCast (remLast (unsafeCast vec))

/**
 * Creates a byte array of the specified size.
 */
pub
byteArray : Int -> ByteArray
byteArray size = mkByteArray size

/**
 * Creates a int16 array of the specified size.
 */
pub
int16Array : Int -> Int16Array
int16Array size = mkInt16Array size

/**
 * Creates a int32 array of the specified size.
 */
pub
intArray : Int -> Int32Array
intArray size = mkInt32Array size

/**
 * Creates a int64 array of the specified size.
 */
pub
int64Array : Int -> Int64Array
int64Array size = mkInt64Array size

/**
 * Creates a float32 array of the specified size.
 */
pub
float32Array : Int -> Float32Array
float32Array size = mkFloat32Array size

/**
 * Creates a float64 array of the specified size.
 */
pub
floatArray : Int -> Float64Array
floatArray size = mkFloat64Array size

/**
 * Creates a char array of the specified size.
 */
pub
charArray : Int -> CharArray
charArray size = mkCharArray size

/**
 * Creates a boolean array of the specified size.
 */
pub
booleanArray : Int -> BooleanArray
booleanArray size = mkBooleanArray size

/**
 * Creates an Object array of the specified size.
 */
pub
objectArray : Int -> Array Object
objectArray size = mkObjectArray size

/**
 * Gets the element of the array at the
 * specified index.
 */
pub
arrayGet : Int -> Array a -> a
arrayGet index arr = unsafeCast (getArray index (unsafeCast arr))

/**
 * Sets the element of the array at the
 * specified index.
 */
pub
arraySet : Int -> a -> Array a -> Unit
arraySet index x arr = setArray index (unsafeCast x) (unsafeCast arr)

/**
 * Converts a Vector of some type `a` to an Array of `a`.
 */
pub
arrayOf : Vector a -> Array a
arrayOf vec = unsafeCast (vecToArr (unsafeCast vec))

/**
 * Returns a formatted string using the specified format string and arguments.
 * See java.util.Formatter for format explanation.
 */
pub
format : String -> Vector a -> String
format str vec = sformat str (unsafeCast (arrayOf vec))

/**
 * Represents the possibility of a missing value.
 */
pub+
type Option a = Some a | None

/**
 * Returns the value contained in this Option
 * or the default value.
 */
pub
(?:) : Option a -> a -> a
(?:) opt def =
  case opt of
    Some x -> x
    None -> def

/**
 * The type of things that can be concatenated.
 */
pub+
opaque type Concat a = { concat : a -> a -> a }

/**
 * Concatenate 2 concatenable values together.
 */
pub
(++) : {{ Concat a }} -> a -> a -> a
(++) {{Concat app}} x y = app.concat x y

pub instance
concatString : Concat String
concatString = Concat { concat: \s s2 -> concat s s2 }

pub instance
concatVector : Concat (Vector a)
concatVector = Concat { concat: \v v2 -> unsafeCast (vecConcat (unsafeCast v) (unsafeCast v2)) }

pub instance
concatSet : Concat (Set a)
concatSet = Concat { concat: \s s2 -> unsafeCast (union (unsafeCast s) (unsafeCast s2)) }

concatOption_ : Concat a -> Option a -> Option a -> Option a
concatOption_ (Concat ap) =
  case _, _ of
    Some x, Some y -> Some (ap.concat x y)
    _, _ -> None

pub instance
concatOption : {{ Concat a }} -> Concat (Option a)
concatOption {{ap}} = Concat { concat: concatOption_ ap }

/**
 * The type of things that can be added together
 * using the + operator.
 */
pub+
opaque type Plus a = { plus : a -> a -> a }

/**
 * Adds x and y.
 */
pub
(+) : {{ Plus a }} -> a -> a -> a
(+) {{Plus p}} x y = p.plus x y

pub instance
plusInt32 : Plus Int32
plusInt32 = Plus { plus: \x y -> sumInt x y }

pub instance
plusInt64 : Plus Int64
plusInt64 = Plus { plus: \x y -> sumInt64 x y }

pub instance
plusFloat32 : Plus Float32
plusFloat32 = Plus { plus: \x y -> sumFloat32 x y }

pub instance
plusFloat64 : Plus Float64
plusFloat64 = Plus { plus: \x y -> sumFloat64 x y }

/**
 * The type of things that can be subtracted
 * using the - operator.
 */
pub+
opaque type Minus a = { minus : a -> a -> a }

/**
 * Subtracts x and y.
 */
pub
(-) : {{ Minus a }} -> a -> a -> a
(-) {{Minus p}} x y = p.minus x y

pub instance
minusInt32 : Minus Int32
minusInt32 = Minus { minus: \x y -> subInt x y }

pub instance
minusInt64 : Minus Int64
minusInt64 = Minus { minus: \x y -> subInt64 x y }

pub instance
minusFloat32 : Minus Float32
minusFloat32 = Minus { minus: \x y -> subFloat32 x y }

pub instance
minusFloat64 : Minus Float64
minusFloat64 = Minus { minus: \x y -> subFloat64 x y }

/**
 * The type of things that can be multiplied together
 * using the * operator.
 */
pub+
opaque type Mult a = { mult : a -> a -> a }

/**
 * Multiplies x and y.
 */
pub
(*) : {{ Mult a }} -> a -> a -> a
(*) {{Mult p}} x y = p.mult x y

pub instance
multInt32 : Mult Int32
multInt32 = Mult { mult: \x y -> mulInt x y }

pub instance
multInt64 : Mult Int64
multInt64 = Mult { mult: \x y -> mulInt64 x y }

pub instance
multFloat32 : Mult Float32
multFloat32 = Mult { mult: \x y -> mulFloat32 x y }

pub instance
multFloat64 : Mult Float64
multFloat64 = Mult { mult: \x y -> mulFloat64 x y }

/**
 * The type of things that can be divided
 * using the / operator.
 */
pub+
opaque type Divide a = { divide : a -> a -> a }

/**
 * Divides x by y.
 */
pub
(/) : {{ Divide a }} -> a -> a -> a
(/) {{Divide p}} x y = p.divide x y

pub instance
divideInt32 : Divide Int32
divideInt32 = Divide { divide: \x y -> divInt x y }

pub instance
divideInt64 : Divide Int64
divideInt64 = Divide { divide: \x y -> divInt64 x y }

pub instance
divideFloat32 : Divide Float32
divideFloat32 = Divide { divide: \x y -> divFloat32 x y }

pub instance
divideFloat64 : Divide Float64
divideFloat64 = Divide { divide: \x y -> divFloat64 x y }

/**
 * The type of things that can be counted / have size.
 */
pub+
opaque type Count a = { count : a -> Int64 }

/**
 * Returns the size of this countable value.
 */
pub
count : {{ Count a }} -> a -> Int64
count {{Count s}} x = s.count x

pub instance
countString : Count String
countString = Count { count: \s -> strLength s |> int64 }

pub instance
countVector : Count (Vector a)
countVector = Count { count: \vec -> sizeVec (unsafeCast vec) }

pub instance
countSet : Count (Set a)
countSet = Count { count: \set -> sizeSet (unsafeCast set) }

pub instance
countArray : Count (Array a)
countArray = Count { count: \arr -> getArrayLength (unsafeCast arr) |> int64 }

pub instance
countRecord : Count { | a }
countRecord = Count { count: \rec -> recSize (unsafeCast rec) }

/**
 * The type of things that have a String representation.
 */
pub+
opaque type Show a = { show : a -> String }

/**
 * Converts this value to a String.
 */
pub
show : {{ Show a }} -> a -> String
show {{Show s}} x = s.show x

/**
 * Like `println` but transforms x to a String using `show` first.
 */
pub
printlnShow : {{ Show a }} -> a -> Unit
printlnShow {{Show s}} x = println (s.show x)

pub instance
showString : Show String
showString = Show { show: identity }

pub instance
showByte : Show Byte
showByte = Show { show: toString }

pub instance
showInt16 : Show Int16
showInt16 = Show { show: toString }

pub instance
showInt32 : Show Int32
showInt32 = Show { show: toString }

pub instance
showInt64 : Show Int64
showInt64 = Show { show: toString }

pub instance
showFloat32 : Show Float32
showFloat32 = Show { show: toString }

pub instance
showFloat64 : Show Float64
showFloat64 = Show { show: toString }

pub instance
showChar : Show Char
showChar = Show { show: toString }

pub instance
showBoolean : Show Boolean
showBoolean = Show { show: toString }

showOpt : Show a -> Option a -> String
showOpt (Show s) =
  case _ of
    Some x -> format "(Some %s)" [s.show x]
    None -> "None"

pub instance
showOption : {{ Show a }} -> Show (Option a)
showOption {{s}} = Show { show: showOpt s }

pub instance
showVector : {{ Show a }} -> Show (Vector a)
showVector {{Show s}} = Show { show: \v -> toStringVector (unsafeCast v) (unsafeCast s.show) }

pub instance
showSet : {{ Show a }} -> Show (Set a)
showSet {{Show s}} = Show { show: \set -> toStringSet (unsafeCast set) (unsafeCast s.show) }

pub instance
showArray : {{ Show a }} -> Show (Array a)
showArray {{Show s}} = Show { show: \a -> toStringArray (unsafeCast a) (unsafeCast s.show) }

/**
 * The type of things that support equality comparison.
 */
pub+
opaque type Equals a = { equals : a -> a -> Boolean }

/**
 * Returns true if the two values are equal.
 */
pub
(==) : {{ Equals a }} -> a -> a -> Boolean
(==) {{Equals eq}} x y = eq.equals x y

/**
 * Returns true if the two values are *not* equal.
 */
pub
(!=) : {{ Equals a }} -> a -> a -> Boolean
(!=) {{Equals eq}} x y = not (eq.equals x y)

pub instance
eqByte : Equals Byte
eqByte = Equals { equals: \x y -> equiByte x y }

pub instance
eqInt16 : Equals Int16
eqInt16 = Equals { equals: \x y -> equiInt16 x y }

pub instance
eqInt32 : Equals Int32
eqInt32 = Equals { equals: \x y -> equiInt32 x y }

pub instance
eqInt64 : Equals Int64
eqInt64 = Equals { equals: \x y -> equiInt64 x y }

pub instance
eqFloat32 : Equals Float32
eqFloat32 = Equals { equals: \x y -> equiFloat32 x y }

pub instance
eqFloat64 : Equals Float64
eqFloat64 = Equals { equals: \x y -> equiFloat64 x y }

pub instance
eqChar : Equals Char
eqChar = Equals { equals: \x y -> equiChar x y }

equalsBoolean : Boolean -> Boolean -> Boolean
equalsBoolean =
  case _, _ of
    true, true -> true
    false, false -> true
    _, _ -> false

pub instance
eqBoolean : Equals Boolean
eqBoolean = Equals { equals: equalsBoolean }

pub instance
eqString : Equals String
eqString = Equals { equals: \x y -> equalsString x y }

pub instance
eqVector : {{ Equals a }} -> Equals (Vector a)
eqVector {{Equals eq}} = Equals { equals: \x y -> equalsVector (unsafeCast x) (unsafeCast y) (unsafeCast eq.equals) }

pub instance
eqSet : {{ Equals a }} -> Equals (Set a)
eqSet {{Equals eq}} = Equals { equals: \x y -> equalsSet (unsafeCast x) (unsafeCast y) (unsafeCast eq.equals) }

pub instance
eqArray : {{ Equals a }} -> Equals (Array a)
eqArray {{Equals eq}} = Equals { equals: \x y -> equalsArray (unsafeCast x) (unsafeCast y) (unsafeCast eq.equals) }

equalsOption : Equals a -> Option a -> Option a -> Boolean
equalsOption (Equals eq) =
  case _, _ of
    Some x, Some y -> eq.equals x y
    None, None -> true
    _, _ -> false

pub instance
eqOption : {{ Equals a }} -> Equals (Option a)
eqOption {{eq}} = Equals { equals: equalsOption eq }

/**
 * The ordering type represents the outcome
 * of comparing 2 values:
 *
 * GT -> bigger than
 * EQ -> equals
 * LT -> less than
 */
pub+
type Ordering = GT | LT | EQ

equalsOrdering : Ordering -> Ordering -> Boolean
equalsOrdering =
  case _, _ of
    GT, GT -> true
    EQ, EQ -> true
    LT, LT -> true
    _, _ -> false

pub instance
eqOrdering : Equals Ordering
eqOrdering = Equals { equals: equalsOrdering }

pub instance
showOrdering : Show Ordering
showOrdering = Show { show: toString }

/**
 * The type of things that can be ordered.
 */
pub+
opaque type Ord a = (Equals a) { compare : a -> a -> Ordering }

/**
 * Returns true if x is greater than y.
 */
pub
(>) : {{ Ord a }} -> a -> a -> Boolean
(>) {{Ord _ o}} x y =
  case o.compare x y of
    GT -> true
    _ -> false

/**
 * Returns true if x is smaller than y.
 */
pub
(<) : {{ Ord a }} -> a -> a -> Boolean
(<) {{Ord _ o}} x y =
  case o.compare x y of
    LT -> true
    _ -> false

/**
 * Returns true if x is greater than or equal y.
 */
pub
(>=) : {{ Ord a }} -> a -> a -> Boolean
(>=) {{Ord _ o}} x y =
  case o.compare x y of
    LT -> false
    _ -> true

/**
 * Returns true if x is smaller than or equal y.
 */
pub
(<=) : {{ Ord a }} -> a -> a -> Boolean
(<=) {{Ord _ o}} x y =
  case o.compare x y of
    GT -> false
    _ -> true

pub instance
ordInt32 : Ord Int32
ordInt32 = Ord eqInt32 { compare: unsafeCast (compareInt LT EQ GT) }

pub instance
ordInt64 : Ord Int64
ordInt64 = Ord eqInt64 { compare: unsafeCast (compareLong LT EQ GT) }

pub instance
ordFloat64 : Ord Float64
ordFloat64 = Ord eqFloat64 { compare: unsafeCast (compareDouble LT EQ GT) }

pub instance
ordByte : Ord Byte
ordByte = Ord eqByte { compare: \x y -> let comp = unsafeCast (compareInt LT EQ GT) in comp (bToI x) (bToI y) }

pub instance
ordInt16 : Ord Int16
ordInt16 = Ord eqInt16 { compare: \x y -> let comp = unsafeCast (compareInt LT EQ GT) in comp (sToI x) (sToI y) }

pub instance
ordFloat32 : Ord Float32
ordFloat32 = Ord eqFloat32 { compare: \x y -> let comp = unsafeCast (compareDouble LT EQ GT) in comp (fToD x) (fToD y) }

pub instance
ordChar : Ord Char
ordChar = Ord eqChar { compare: unsafeCast (compareChar LT EQ GT) }

compareBoolean : Boolean -> Boolean -> Ordering
compareBoolean =
  case _, _ of
    true, true -> EQ
    false, false -> EQ
    true, false -> GT
    false, true -> LT

pub instance
ordBoolean : Ord Boolean
ordBoolean = Ord eqBoolean { compare: compareBoolean }

pub instance
ordString : Ord String
ordString = Ord eqString { compare: unsafeCast (compareString LT EQ GT) }

compareOption : Ord a -> Option a -> Option a -> Ordering
compareOption (Ord _ o) = case _, _ of
  Some x, Some y -> o.compare x y
  Some _, None -> GT
  None, Some _ -> LT
  None, None -> EQ

/**
 * Compares two options if their values are comparable.
 * None values are always smaller then Some.
 */
pub instance
ordOption : {{ Ord a }} -> Ord (Option a)
ordOption {{(Ord eq _) as ord}} = Ord (eqOption {{eq}}) { compare: compareOption ord }

/**
 * Represents a computation that can fail.
 * Should be used to represent errors instead of exceptions.
 */
pub+
type Result ok err = Ok ok | Err err

equalsResult : Equals ok -> Equals err -> Result ok err -> Result ok err -> Boolean
equalsResult (Equals eq1) (Equals eq2) =
  case _, _ of
    Ok x, Ok y -> eq1.equals x y
    Err x, Err y -> eq2.equals x y
    _, _ -> false

pub instance
eqResult : {{ Equals ok }} -> {{ Equals err }} -> Equals (Result ok err)
eqResult {{eq1}} {{eq2}} = Equals { equals: equalsResult eq1 eq2 }

showRes : Show ok -> Show err -> Result ok err -> String
showRes (Show s1) (Show s2) =
  case _ of
    Ok x -> format "(Ok %s)" [s1.show x]
    Err x -> format "(Err %s)" [s2.show x]

pub instance
showResult : {{ Show ok }} -> {{ Show err }} -> Show (Result ok err)
showResult {{s1}} {{s2}} = Show { show: showRes s1 s2 }

/**
 * Atoms are a shared, uncoordinated, synchronous reference to an immutable value.
 */
pub
opaque type Atom a = AtomicReference

/**
 * Creates a new Atom to hold x.
 * Should *not* be used to hold a mutable value.
 */
pub
atom : a -> Atom a
atom x = Atom (newAtom (unsafeCast x))

/**
 * Returns the value inside this Atom.
 */
pub
deref : Atom a -> a
deref (Atom a) = unsafeCast (atomGet a)

/**
 * Resets the value of this Atom to x, discarding the old value.
 * Returns x.
 */
pub
reset : a -> Atom a -> a
reset x (Atom a) = do
  atomSet a (unsafeCast x)
  x

/**
 * Swaps the value of this atom by applying a function to the old value.
 * The function *should be free of side effects* as it may be executed
 * multiple times.
 */
pub
swap : (a -> a) -> Atom a -> a
swap f (Atom a) = unsafeCast (swapAtom a (unsafeCast f))

/**
 * Low-level function that receives the old value, the new value and attempts
 * to set the atom to new if old matches.
 * Returns true if it succeeded.
 * Always prefer `swap` over `compareAndSet`.
 */
pub
compareAndSet : a -> a -> Atom a -> Boolean
compareAndSet old new (Atom atm) = atomCmpAndSet atm (unsafeCast old) (unsafeCast new)

equalsAtom : Equals a -> Atom a -> Atom a -> Boolean
equalsAtom (Equals eq) x y = eq.equals (deref x) (deref y)

pub instance
eqAtom : {{ Equals a }} -> Equals (Atom a)
eqAtom {{eq}} = Equals { equals: equalsAtom eq }

pub instance
showAtom : {{ Show a }} -> Show (Atom a)
showAtom {{Show s}} = Show { show: \atm -> format "(Atom %s)" [s.show (deref atm)] }

/**
 * Executes the function for every number from begin (inclusive) to end (exclusive).
 * This is a faster, specialized version of `Vector.forEach (begin .. end) f`.
 */
pub
forEachRange : Int64 -> Int64 -> (Int64 -> a) -> Unit
forEachRange begin end f = eachRange begin end 1 (unsafeCast f)

/**
 * Executes the function starting at begin (inclusive) ending in end (exclusive) with the specified step.
 */
pub
forEachStep : Int64 -> Int64 -> Int -> (Int64 -> a) -> Unit
forEachStep begin end step f = eachRange begin end step (unsafeCast f)

/**
 * Types that can generate a vector over a range.
 */
pub+
opaque type Range a =
  { range: a -> a -> Vector a
  , rangeInclusive: a -> a -> Vector a
  }

/**
 * Returns a vector starting at begin (inclusive) and ending at end (exclusive).
 */
pub
(..) : {{ Range a }} -> a -> a -> Vector a
(..) {{Range r}} begin end = r.range begin end

/**
 * Returns a vector starting at begin (inclusive) and ending at end (inclusive).
 */
pub
(...) : {{ Range a }} -> a -> a -> Vector a
(...) {{Range r}} begin end = r.rangeInclusive begin end

pub instance
rangeInt32 : Range Int32
rangeInt32 = Range
  { range: \begin end -> unsafeCast (vecIntRange begin end)
  , rangeInclusive: \begin end -> unsafeCast (vecIntRange begin (end + 1))
  }

pub instance
rangeInt64 : Range Int64
rangeInt64 = Range
  { range: \begin end -> unsafeCast (vecLongRange begin end)
  , rangeInclusive: \begin end -> unsafeCast (vecLongRange begin (end + 1L))
  }

pub instance
rangeFloat32 : Range Float32
rangeFloat32 = Range
  { range: \begin end -> unsafeCast (vecFloatRange begin end)
  , rangeInclusive: \begin end -> unsafeCast (vecFloatRange begin (end + 1.0F))
  }

pub instance
rangeFloat64 : Range Float64
rangeFloat64 = Range
  { range: \begin end -> unsafeCast (vecDoubleRange begin end)
  , rangeInclusive: \begin end -> unsafeCast (vecDoubleRange begin (end + 1.0))
  }

pub instance
rangeChar : Range Char
rangeChar = Range
  { range: \begin end -> unsafeCast (vecCharRange begin end)
  , rangeInclusive: \begin end -> unsafeCast (vecCharRange begin (intToChar (charToInt end + 1)))
  }