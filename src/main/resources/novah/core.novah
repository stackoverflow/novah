/**
 * The core functions of the language.
 * Imported automatically in every module.
 */
module novah.core

foreign import io.lacuna.bifurcan.IList
foreign import io.lacuna.bifurcan.ISet
foreign import novah.Core
foreign import novah.collections.Record
foreign import java.util.concurrent.atomic.AtomicReference
foreign import java.lang.AssertionError
foreign import java.lang.Math
foreign import java.lang.System

/**
 * A 32-bits Integer
 */
pub
typealias Int = Int32

/**
 * A 64-bits floating point.
 */
pub
typealias Float = Float64

/**
 * Coerce parameter x from type a to b.
 * This is extremely unsafe and should be used only
 * when sure both types are compatible, otherwise
 * a runtime exception will be thrown.
 */
pub
unsafeCast : a -> b
unsafeCast x = x as b

/**
 * Negates a boolean value.
 */
pub
not : Boolean -> Boolean
not b = Core#not(b)

/**
 * Returns its argument unmodified.
 */
pub
identity : a -> a
identity x = x

/**
 * Flips the arguments of a 2-arguments function.
 */
pub
flip : (a -> b -> c) -> (b -> a -> c)
flip f y x = f x y

/**
 * Takes two parameters and returns the first, ignoring the second.
 */
pub
const : a -> b -> a
const x _ = x

/**
 * The railway operator.
 * Applies function f to x.
 * Used to minimize parentheses and have a
 * more intuitive order of execution:
 *
 * `1 .. 100 |> List.reverse |> List.map (_ * 10)`
 * instead of
 * `List.map (_ * 10) (List.reverse (1 .. 100))`
 */
pub
(|>) : a -> (a -> b) -> b
(|>) x f = f x

/**
 * The reverse of the `|>` (railway operator).
 * Applies function f to x.
 * Used to minimize parentheses:
 *
 * `List.map (_ * 10) <| List.reverse <| 1 .. 100`
 * instead of
 * `List.map (_ * 10) (List.sort (1 .. 100))`
 */
pub
(<|) : (a -> b) -> a -> b
(<|) f x = f x

/**
 * Forward function composition operator: `(f >> g) x = g (f x)`
 */
pub
(>>) : (a -> b) -> (b -> c) -> (a -> c)
(>>) f g x = g (f x)

/**
 * Backward function composition operator: `(f << g) x = f (g x)`
 */
pub
(<<) : (b -> c) -> (a -> b) -> (a -> c)
(<<) f g x = f (g x)

/**
 * Returns true if the 2 references point to the same object.
 * This is the same as Java's ==
 */
pub
(===) : a -> a -> Boolean
(===) x y = Core#equivalentObject(x, y)

/**
 * Returns true if the 2 objects *do not* point to the same object.
 * This is the same as Java's !=
 */
pub
(!==) : a -> a -> Boolean
(!==) x y = Core#not(Core#equivalentObject(x, y))

/**
 * Logical `and` operator.
 * Returns true if both conditions are true.
 * This operator will short circuit if fully applied.
 */
pub
(&&) : Boolean -> Boolean -> Boolean
(&&) cond1 cond2 = Core#and(cond1, cond2)

/**
 * Logical `or` operator.
 * Returns true if at least one of the conditions is true.
 * This operator will short circuit if fully applied.
 */
pub
(||) : Boolean -> Boolean -> Boolean
(||) cond1 cond2 = Core#or(cond1, cond2)

/**
 * Prints x to stdout and appends a new line.
 */
pub
println : a -> Unit
println x = System#-out#println(x as Object)

/**
 * Prints x to the stdout.
 */
pub
print : a -> Unit
print x = System#-out#print(x as Object)

/**
 * Converts a value to String using the
 * native Java toString method.
 */
pub
toString : a -> String
toString x = (x as Object)#toString()

/**
 * Throws an exception stating that this code is still undergoing implementation.
 * Should be used a placeholder for future code.
 */
pub
todo : String -> a
todo msg = throw AssertionError#new(format "Not implemented: %s" [msg] as Object)

/**
 * Converts this 64-bit integer to a 32-bit integer.
 */
pub
int : Int64 -> Int32
int (l : Int64) = l#intValue()

/**
 * Converts this 32-bit integer to a 64-bit integer.
 */
pub
int64 : Int32 -> Int64
int64 (i : Int32) = i#longValue()

/**
 * Returns the value at index for this list.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: ~O(1)
 */
pub
(!) : List a -> Int64 -> a
(!) (list : List a) index = list#nth(index)

/**
 * Sets the value of this list at the specified index to x.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: ~O(1)
 */
pub
setAt : Int64 -> a -> List a -> List a
setAt index x (list : List a) = list#set(index, x)

/**
 * Updates the value of this list at the specified index by applying function f to the old value.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: ~O(1)
 */
pub
updateAt : Int64 -> (a -> a) -> List a -> List a
updateAt index f (list : List a) = list#set(index, f (list ! index))

/**
 * Appends x to the beginning of this list.
 * Runtime: ~O(1)
 */
pub
addFirst : a -> List a -> List a
addFirst x (list : List a) = list#addFirst(x)

/**
 * Appends x to the end of this list.
 * Runtime: ~O(1)
 */
pub
addLast : a -> List a -> List a
addLast x (list : List a) = list#addLast(x)

/**
 * Removes the first element of this list.
 * Runtime: ~O(1)
 */
pub
removeFirst : List a -> List a
removeFirst (list : List a) = list#removeFirst()

/**
 * Removes the last element of this list.
 * Runtime: ~O(1)
 */
pub
removeLast : List a -> List a
removeLast (list : List a) = list#removeLast()

/**
 * Gets the element of the array at the specified index.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: O(1)
 */
pub
aget : Int32 -> Array a -> a
aget index arr = Core#getArray(index, arr)

/**
 * Sets the element of the array at the specified index.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: O(1)
 */
pub
aset : Int32-> a -> Array a -> Unit
aset index x arr = Core#setArray(index, x, arr)

/**
 * Updates the element of the array at the specified index by applying this function
 * to the old value.
 * *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
 * Runtime: O(1)
 */
pub
aupdate : Int32 -> (a -> a) -> Array a -> Unit
aupdate index updateFn arr = Core#setArray(index, updateFn Core#getArray(index, arr), arr)

/**
 * Converts a list of some type `a` to an Array of `a`.
 * Runtime: O(n)
 */
pub
arrayOf : List a -> Array a
arrayOf vec = (vec as IList a)#toArray() as Array a

/**
 * Returns a formatted string using the specified format string and arguments.
 * See `java.util.Formatter` for format explanation.
 */
pub
format : String -> List a -> String
format str list = String#format(str, arrayOf list as Array Object)

/**
 * Prints the formated string to stdout.
 */
pub
printfln : String -> List a -> Unit
printfln form args = println (format form args)

/**
 * Executes the action when the condition is `true`.
 * Used for side effects.
 */
pub
when : Boolean -> (Unit -> a) -> Unit
when cond action =
  if cond
    then
      action ()
      ()
    else ()

/**
 * Coerces a value to a nullable.
 * Should only be used for Java interoperability
 * when a foreign imported value can be null
 * or a method can return null.
 * `let possibleNullResult = foreignFunction x y z |> nullable`
 */
pub
nullable : a -> Nullable a
nullable x = unsafeCast x

/**
 * Represents the possibility of a missing value.
 */
pub+
type Option a = Some a | None

/**
 * Returns the value contained in this option
 * or the default value.
 */
pub
(?:) : Option a -> a -> a
(?:) opt def =
  case opt of
    Some x -> x
    None -> def

/**
 * The type of things that can be concatenated.
 */
pub+
opaque type Concat a = a -> a -> a

/**
 * Concatenate 2 concatenable values together.
 */
pub
(++) : {{ Concat a }} -> a -> a -> a
(++) {{Concat concat}} x y = concat x y

pub instance
concatString : Concat String
concatString = Concat \s s2 -> (s : String)#concat(s2)

pub instance
concatList : Concat (List a)
concatList = Concat \v v2 -> (v : List a)#concat(v2 as IList a) as List a

pub instance
concatSet : Concat (Set a)
concatSet = Concat \s s2 -> (s : Set a)#union(s2 as ISet a)

concatOption_ : Concat a -> Option a -> Option a -> Option a
concatOption_ (Concat concat) =
  case _, _ of
    Some x, Some y -> Some (concat x y)
    _, _ -> None

pub instance
concatOption : {{ Concat a }} -> Concat (Option a)
concatOption {{ap}} = Concat (concatOption_ ap)

/**
 * The type of things that can be added together
 * using the + operator.
 */
pub+
opaque type Plus a = a -> a -> a

/**
 * Adds x and y.
 */
pub
(+) : {{ Plus a }} -> a -> a -> a
(+) {{Plus plus}} x y = plus x y

pub instance
plusInt32 : Plus Int32
plusInt32 = Plus \(x : Int32) y -> Core#sum(x, y)

pub instance
plusInt64 : Plus Int64
plusInt64 = Plus \(x : Int64) y -> Core#sum(x, y)

pub instance
plusFloat32 : Plus Float32
plusFloat32 = Plus \(x : Float32) y -> Core#sum(x, y)

pub instance
plusFloat64 : Plus Float64
plusFloat64 = Plus \(x : Float64) y -> Core#sum(x, y)

/**
 * The type of things that can be subtracted
 * using the - operator.
 */
pub+
opaque type Minus a = a -> a -> a

/**
 * Subtracts x and y.
 */
pub
(-) : {{ Minus a }} -> a -> a -> a
(-) {{Minus minus}} x y = minus x y

pub instance
minusInt32 : Minus Int32
minusInt32 = Minus \(x : Int32) y -> Core#sub(x, y)

pub instance
minusInt64 : Minus Int64
minusInt64 = Minus \(x : Int64) y -> Core#sub(x, y)

pub instance
minusFloat32 : Minus Float32
minusFloat32 = Minus \(x : Float32) y -> Core#sub(x, y)

pub instance
minusFloat64 : Minus Float64
minusFloat64 = Minus \(x : Float64) y -> Core#sub(x, y)

/**
 * The type of things that can be multiplied together
 * using the * operator.
 */
pub+
opaque type Mult a = a -> a -> a

/**
 * Multiplies x and y.
 */
pub
(*) : {{ Mult a }} -> a -> a -> a
(*) {{Mult mult}} x y = mult x y

pub instance
multInt32 : Mult Int32
multInt32 = Mult \(x : Int32) y -> Core#mult(x, y)

pub instance
multInt64 : Mult Int64
multInt64 = Mult \(x : Int64) y -> Core#mult(x, y)

pub instance
multFloat32 : Mult Float32
multFloat32 = Mult \(x : Float32) y -> Core#mult(x, y)

pub instance
multFloat64 : Mult Float64
multFloat64 = Mult \(x : Float64) y -> Core#mult(x, y)

/**
 * The type of things that can be divided
 * using the / operator.
 */
pub+
opaque type Divide a = a -> a -> a

/**
 * Divides x by y.
 */
pub
(/) : {{ Divide a }} -> a -> a -> a
(/) {{Divide divide}} x y = divide x y

pub instance
divideInt32 : Divide Int32
divideInt32 = Divide \(x : Int32) y -> Core#div(x, y)

pub instance
divideInt64 : Divide Int64
divideInt64 = Divide \(x : Int64) y -> Core#div(x, y)

pub instance
divideFloat32 : Divide Float32
divideFloat32 = Divide \(x : Float32) y -> Core#div(x, y)

pub instance
divideFloat64 : Divide Float64
divideFloat64 = Divide \(x : Float64) y -> Core#div(x, y)

/**
 * Returns x raised to the power of y.
 * Follows the same special cases as `java.lang.Math.pow`.
 */
pub
(^) : Float64 -> Float64 -> Float64
(^) x y = Math#pow(x, y)

/**
 * The type of things that have a String representation.
 */
pub+
opaque type Show a = a -> String

/**
 * Converts this value to a String.
 */
pub
show : {{ Show a }} -> a -> String
show {{Show sh}} x = sh x

/**
 * Like `println` but transforms x to a String using `show` first.
 */
pub
printlnShow : {{ Show a }} -> a -> Unit
printlnShow {{Show sh}} x = println (sh x)

pub instance
showString : Show String
showString = Show identity

pub instance
showByte : Show Byte
showByte = Show toString

pub instance
showInt16 : Show Int16
showInt16 = Show toString

pub instance
showInt32 : Show Int32
showInt32 = Show toString

pub instance
showInt64 : Show Int64
showInt64 = Show toString

pub instance
showFloat32 : Show Float32
showFloat32 = Show toString

pub instance
showFloat64 : Show Float64
showFloat64 = Show toString

pub instance
showChar : Show Char
showChar = Show toString

pub instance
showBoolean : Show Boolean
showBoolean = Show toString

showOpt : Show a -> Option a -> String
showOpt (Show sh) =
  case _ of
    Some x -> format "(Some %s)" [sh x]
    None -> "None"

pub instance
showOption : {{ Show a }} -> Show (Option a)
showOption {{s}} = Show (showOpt s)

pub instance
showList : {{ Show a }} -> Show (List a)
showList {{Show sh}} = Show Core#toStringList(_, sh)

pub instance
showSet : {{ Show a }} -> Show (Set a)
showSet {{Show sh}} = Show Core#toStringSet(_, sh)

pub instance
showArray : {{ Show a }} -> Show (Array a)
showArray {{Show sh}} = Show Core#toStringArray(_, sh)

showNull : Show a -> Nullable a -> String
showNull (Show sh) x =
  if x === null
    then "null"
    else sh (x as a)

pub instance
showNullable : {{ Show a }} -> Show (Nullable a)
showNullable {{s}} = Show (showNull s)

/**
 * The type of things that support equality comparison.
 */
pub+
opaque type Equals a = a -> a -> Boolean

/**
 * Returns true if the two values are equal.
 */
pub
(==) : {{ Equals a }} -> a -> a -> Boolean
(==) {{Equals eq}} x y = eq x y

/**
 * Returns true if the two values are *not* equal.
 */
pub
(!=) : {{ Equals a }} -> a -> a -> Boolean
(!=) {{Equals eq}} x y = not (eq x y)

pub instance
eqByte : Equals Byte
eqByte = Equals \(x : Byte) y -> Core#equivalent(x, y)

pub instance
eqInt16 : Equals Int16
eqInt16 = Equals \(x : Int16) y -> Core#equivalent(x, y)

pub instance
eqInt32 : Equals Int32
eqInt32 = Equals \(x : Int32) y -> Core#equivalent(x, y)

pub instance
eqInt64 : Equals Int64
eqInt64 = Equals \(x : Int64) y -> Core#equivalent(x, y)

pub instance
eqFloat32 : Equals Float32
eqFloat32 = Equals \(x : Float32) y -> Core#equivalent(x, y)

pub instance
eqFloat64 : Equals Float64
eqFloat64 = Equals \(x : Float64) y -> Core#equivalent(x, y)

pub instance
eqChar : Equals Char
eqChar = Equals \(x : Char) y -> Core#equivalent(x, y)

equalsBoolean : Boolean -> Boolean -> Boolean
equalsBoolean =
  case _, _ of
    true, true -> true
    false, false -> true
    _, _ -> false

pub instance
eqBoolean : Equals Boolean
eqBoolean = Equals equalsBoolean

pub instance
eqString : Equals String
eqString = Equals \(x : String) y -> x#equals((y : String) as Object)

pub instance
eqList : {{ Equals a }} -> Equals (List a)
eqList {{Equals eq}} = Equals \x y -> Core#equalsList(x, y, eq)

pub instance
eqSet : {{ Equals a }} -> Equals (Set a)
eqSet {{Equals eq}} = Equals \x y -> Core#equalsSet(x, y, eq)

pub instance
eqArray : {{ Equals a }} -> Equals (Array a)
eqArray {{Equals eq}} = Equals \x y -> Core#equalsArray(x, y, eq)

equalsOption : Equals a -> Option a -> Option a -> Boolean
equalsOption (Equals eq) =
  case _, _ of
    Some x, Some y -> eq x y
    None, None -> true
    _, _ -> false

pub instance
eqOption : {{ Equals a }} -> Equals (Option a)
eqOption {{eq}} = Equals (equalsOption eq)

equalsNullable : Equals a -> Nullable a -> Nullable a -> Boolean
equalsNullable (Equals eq) x y =
  if x === null && y === null
    then true
    else
      if x === null || y === null
        then false
        else eq (x as a) (y as a)

pub instance
eqNullable : {{ Equals a }} -> Equals (Nullable a)
eqNullable {{eq}} = Equals (equalsNullable eq)

/**
 * Compare if the two records are equals
 * according to Java's equality.
 */
pub
recordEquals : { | r } -> { | r } -> Boolean
recordEquals r1 r2 = (r1 as Record)#equals(r2 as Object)

/**
 * The ordering type represents the outcome
 * of comparing 2 values:
 *
 * GT -> bigger than
 * EQ -> equals
 * LT -> less than
 */
pub+
type Ordering = GT | LT | EQ

equalsOrdering : Ordering -> Ordering -> Boolean
equalsOrdering =
  case _, _ of
    GT, GT -> true
    EQ, EQ -> true
    LT, LT -> true
    _, _ -> false

pub instance
eqOrdering : Equals Ordering
eqOrdering = Equals equalsOrdering

pub instance
showOrdering : Show Ordering
showOrdering = Show toString

/**
 * The type of things that can be ordered.
 */
pub+
type Ord a = Ord (Equals a) { compare : a -> a -> Ordering }

/**
 * Returns the result of comparing two Ord instances.
 */
pub
compare : {{ Ord a }} -> a -> a -> Ordering
compare {{Ord _ o}} x y = o.compare x y

/**
 * Returns true if x is greater than y.
 */
pub
(>) : {{ Ord a }} -> a -> a -> Boolean
(>) {{Ord _ o}} x y =
  case o.compare x y of
    GT -> true
    _ -> false

/**
 * Returns true if x is smaller than y.
 */
pub
(<) : {{ Ord a }} -> a -> a -> Boolean
(<) {{Ord _ o}} x y =
  case o.compare x y of
    LT -> true
    _ -> false

/**
 * Returns true if x is greater than or equal y.
 */
pub
(>=) : {{ Ord a }} -> a -> a -> Boolean
(>=) {{Ord _ o}} x y =
  case o.compare x y of
    LT -> false
    _ -> true

/**
 * Returns true if x is smaller than or equal y.
 */
pub
(<=) : {{ Ord a }} -> a -> a -> Boolean
(<=) {{Ord _ o}} x y =
  case o.compare x y of
    GT -> false
    _ -> true

pub instance
ordInt32 : Ord Int32
ordInt32 = Ord eqInt32 { compare: unsafeCast Core#compareInt(LT as Object, EQ as Object, GT as Object) }

pub instance
ordInt64 : Ord Int64
ordInt64 = Ord eqInt64 { compare: unsafeCast Core#compareLong(LT as Object, EQ as Object, GT as Object) }

pub instance
ordFloat64 : Ord Float64
ordFloat64 = Ord eqFloat64 { compare: unsafeCast Core#compareDouble(LT as Object, EQ as Object, GT as Object) }

pub instance
ordByte : Ord Byte
ordByte =
  Ord eqByte
    { compare:
      \(x : Byte) (y : Byte) ->
        let comp = unsafeCast Core#compareInt(LT as Object, EQ as Object, GT as Object)
        comp x#intValue() y#intValue()
    }

pub instance
ordInt16 : Ord Int16
ordInt16 =
  Ord eqInt16
    { compare:
      \(x : Int16) (y : Int16) ->
        let comp = unsafeCast Core#compareInt(LT as Object, EQ as Object, GT as Object)
        comp x#intValue() y#intValue()
    }

pub instance
ordFloat32 : Ord Float32
ordFloat32 =
  Ord eqFloat32
    { compare:
      \(x : Float32) (y : Float32) ->
        let comp = unsafeCast Core#compareDouble(LT as Object, EQ as Object, GT as Object)
        comp x#doubleValue() y#doubleValue()
    }

pub instance
ordChar : Ord Char
ordChar = Ord eqChar { compare: unsafeCast Core#compareChar(LT as Object, EQ as Object, GT as Object) }

compareBoolean : Boolean -> Boolean -> Ordering
compareBoolean =
  case _, _ of
    true, true -> EQ
    false, false -> EQ
    true, false -> GT
    false, true -> LT

pub instance
ordBoolean : Ord Boolean
ordBoolean = Ord eqBoolean { compare: compareBoolean }

pub instance
ordString : Ord String
ordString = Ord eqString { compare: unsafeCast Core#compareString(LT as Object, EQ as Object, GT as Object) }

compareOption : Ord a -> Option a -> Option a -> Ordering
compareOption (Ord _ o) =
  case _, _ of
    Some x, Some y -> o.compare x y
    Some _, None -> GT
    None, Some _ -> LT
    None, None -> EQ

/**
 * Compares two options if their values are comparable.
 * None values are always smaller then Some.
 */
pub instance
ordOption : {{ Ord a }} -> Ord (Option a)
ordOption {{(Ord eq _) as ord}} = Ord (eqOption {{eq}}) { compare: compareOption ord }

/**
 * A type for some miscelaneous number operations.
 */
pub+
opaque type NumberOps a =
  { remainder : a -> a -> a
  , zero : a
  , even: a -> Boolean
  , min: a -> a -> a
  , max: a -> a -> a
  }

/**
 * Returns the remainder of dividing x by y.
 */
pub
(%) : {{ NumberOps a }} -> a -> a -> a
(%) {{NumberOps r}} x y = r.remainder x y

/**
 * Returns true if this number is odd.
 */
pub
isOdd : {{ NumberOps a }} -> a -> Boolean
isOdd {{NumberOps r}} x = not (r.even x)

/**
 * Returns true if this number is even.
 */
pub
isEven : {{ NumberOps a }} -> a -> Boolean
isEven {{NumberOps r}} x = r.even x

pub instance
numberOpsInt32 : NumberOps Int32
numberOpsInt32 =
  NumberOps
    { remainder: \x y -> Core#intRemainder(x, y)
    , zero: 0
    , even: \x -> Core#intRemainder(x, 2) == 0
    , min: \(x : Int32) y -> Math#min(x, y)
    , max: \(x : Int32) y -> Math#max(x, y)
    }

pub instance
numberOpsInt64 : NumberOps Int64
numberOpsInt64 =
  NumberOps
    { remainder: \x y -> Core#longRemainder(x, y)
    , zero: 0L
    , even: \x -> Core#longRemainder(x, 2L) == 0L
    , min: \(x : Int64) y -> Math#min(x, y)
    , max: \(x : Int64) y -> Math#max(x, y)
    }

pub instance
numberOpsFloat32 : NumberOps Float32
numberOpsFloat32 =
  NumberOps
    { remainder: \x y -> Core#floatRemainder(x, y)
    , zero: 0F
    , even: \x -> Core#floatRemainder(x, 2F) == 0F
    , min: \(x : Float32) y -> Math#min(x, y)
    , max: \(x : Float32) y -> Math#max(x, y)
    }

pub instance
numberOpsFloat64 : NumberOps Float64
numberOpsFloat64 =
  NumberOps
    { remainder: \x y -> Core#doubleRemainder(x, y)
    , zero: 0.0
    , even: \x -> Core#doubleRemainder(x, 2.0) == 0.0
    , min: \(x : Float64) y -> Math#min(x, y)
    , max: \(x : Float64) y -> Math#max(x, y)
    }

/**
 * Represents a type that supports bitwise operations.
 */
pub+
opaque type BitOperator a =
  { and : a -> a -> a
  , or : a -> a -> a
  , xor : a -> a -> a
  , not : a -> a
  , shiftLeft : a -> a -> a
  , shiftRight : a -> a -> a
  , unsignedShiftRight: a -> a -> a
  }

/**
 * Returns the biwise and between x and y.
 * Equivalent to Java's `&`.
 */
pub
bitAnd : {{ BitOperator a }} -> a -> a -> a
bitAnd {{BitOperator b}} x y = b.and x y

/**
 * Returns the biwise or between x and y.
 * Equivalent to Java's `|`.
 */
pub
bitOr : {{ BitOperator a }} -> a -> a -> a
bitOr {{BitOperator b}} x y = b.or x y

/**
 * Returns the biwise xor between x and y.
 * Equivalent to Java's `^`.
 */
pub
bitXor : {{ BitOperator a }} -> a -> a -> a
bitXor {{BitOperator b}} x y = b.xor x y

/**
 * Returns the bit complement of x.
 * Equivalent to Java's `~`.
 */
pub
bitNot : {{ BitOperator a }} -> a -> a
bitNot {{BitOperator b}} x = b.not x

/**
 * Shifts `x` bitwise to the left by `amount`.
 * Equivalent to Java's `<<`.
 */
pub
bitShiftLeft : {{ BitOperator a }} -> a -> a -> a
bitShiftLeft {{BitOperator b}} x amount = b.shiftLeft x amount

/**
 * Shifts `x` bitwise to the right by `amount`.
 * Equivalent to Java's `>>`.
 */
pub
bitShiftRight : {{ BitOperator a }} -> a -> a -> a
bitShiftRight {{BitOperator b}} x amount = b.shiftRight x amount

/**
 * Shifts `x` bitwise to the right by `amount` (unsigned).
 * Equivalent to Java's `>>>`.
 */
pub
bitUnsignedShiftRight : {{ BitOperator a }} -> a -> a -> a
bitUnsignedShiftRight {{BitOperator b}} x amount = b.unsignedShiftRight x amount

pub instance
bitOperatorByte : BitOperator Byte
bitOperatorByte =
  BitOperator
    { and: \(x : Byte) (y : Byte) -> Core#bitAndInt(x#intValue(), y#intValue())#byteValue()
    , or: \(x : Byte) (y : Byte) -> Core#bitOrInt(x#intValue(), y#intValue())#byteValue()
    , xor: \(x : Byte) (y : Byte) -> Core#bitXorInt(x#intValue(), y#intValue())#byteValue()
    , shiftLeft: \(x : Byte) (y : Byte) -> Core#bitShiftLeftInt(x#intValue(), y#intValue())#byteValue()
    , shiftRight: \(x : Byte) (y : Byte) -> Core#bitShiftRightInt(x#intValue(), y#intValue())#byteValue()
    , unsignedShiftRight: \(x : Byte) (y : Byte) -> Core#unsignedBitShiftRightInt(x#intValue(), y#intValue())#byteValue()
    , not: \(x : Byte) -> Core#bitNotInt(x#intValue())#byteValue()
    }

pub instance
bitOperatorInt16 : BitOperator Int16
bitOperatorInt16 =
  BitOperator
    { and: \(x : Int16) (y : Int16) -> Core#bitAndInt(x#intValue(), y#intValue())#shortValue()
    , or: \(x : Int16) (y : Int16) -> Core#bitOrInt(x#intValue(), y#intValue())#shortValue()
    , xor: \(x : Int16) (y : Int16) -> Core#bitXorInt(x#intValue(), y#intValue())#shortValue()
    , shiftLeft: \(x : Int16) (y : Int16) -> Core#bitShiftLeftInt(x#intValue(), y#intValue())#shortValue()
    , shiftRight: \(x : Int16) (y : Int16) -> Core#bitShiftRightInt(x#intValue(), y#intValue())#shortValue()
    , unsignedShiftRight: \(x : Int16) (y : Int16) -> Core#unsignedBitShiftRightInt(x#intValue(), y#intValue())#shortValue()
    , not: \(x : Int16) -> Core#bitNotInt(x#intValue())#shortValue()
    }

pub instance
bitOperatorInt32 : BitOperator Int32
bitOperatorInt32 =
  BitOperator
    { and: \x y -> Core#bitAndInt(x, y)
    , or: \x y -> Core#bitOrInt(x, y)
    , xor: \x y -> Core#bitXorInt(x, y)
    , shiftLeft: \x y -> Core#bitShiftLeftInt(x, y)
    , shiftRight: \x y -> Core#bitShiftRightInt(x, y)
    , unsignedShiftRight: \x y -> Core#unsignedBitShiftRightInt(x, y)
    , not: \x -> Core#bitNotInt(x)
    }

pub instance
bitOperatorInt64 : BitOperator Int64
bitOperatorInt64 =
  BitOperator
    { and: \x y -> Core#bitAndLong(x, y)
    , or: \x y -> Core#bitOrLong(x, y)
    , xor: \x y -> Core#bitXorLong(x, y)
    , shiftLeft: \x y -> Core#bitShiftLeftLong(x, y)
    , shiftRight: \x y -> Core#bitShiftRightLong(x, y)
    , unsignedShiftRight: \x y -> Core#unsignedBitShiftRightLong(x, y)
    , not: \x -> Core#bitNotLong(x)
    }

/**
 * Represents a computation that can fail.
 * Should be used to represent errors instead of exceptions.
 */
pub+
type Result ok err
  = Ok ok
  | Err err

equalsResult : Equals ok -> Equals err -> Result ok err -> Result ok err -> Boolean
equalsResult (Equals eq1) (Equals eq2) =
  case _, _ of
    Ok x, Ok y -> eq1 x y
    Err x, Err y -> eq2 x y
    _, _ -> false

pub instance
eqResult : {{ Equals ok }} -> {{ Equals err }} -> Equals (Result ok err)
eqResult {{eq1}} {{eq2}} = Equals (equalsResult eq1 eq2)

showRes : Show ok -> Show err -> Result ok err -> String
showRes (Show s1) (Show s2) =
  case _ of
    Ok x -> format "(Ok %s)" [s1 x]
    Err x -> format "(Err %s)" [s2 x]

pub instance
showResult : {{ Show ok }} -> {{ Show err }} -> Show (Result ok err)
showResult {{s1}} {{s2}} = Show (showRes s1 s2)

/**
 * A Tuple containing two values.
 */
pub+
type Tuple a b = Tuple a b

/**
 * Creates a tuple out of two values.
 */
pub
(<>) : a -> b -> Tuple a b
(<>) = Tuple

equalsTuple : Equals a -> Equals b -> Tuple a b -> Tuple a b -> Boolean
equalsTuple (Equals eq1) (Equals eq2) (Tuple x y) (Tuple x2 y2) = eq1 x x2 && eq2 y y2

pub instance
eqTuple : {{ Equals a }} -> {{ Equals b }} -> Equals (Tuple a b)
eqTuple {{eq1}} {{eq2}} = Equals (equalsTuple eq1 eq2)

showTup : Show a -> Show b -> Tuple a b -> String
showTup (Show s1) (Show s2) (Tuple x y) = format "(Tuple %s %s)" [s1 x, s2 y]

pub instance
showTuple : {{ Show a }} -> {{ Show b }} -> Show (Tuple a b)
showTuple {{s1}} {{s2}} = Show (showTup s1 s2)

concatTup : Concat a -> Concat b -> Tuple a b -> Tuple a b -> Tuple a b
concatTup (Concat c1) (Concat c2) (Tuple x y) (Tuple x2 y2) = Tuple (c1 x x2) (c2 y y2)

pub instance
concatTuple : {{ Concat a }} -> {{ Concat b }} -> Concat (Tuple a b)
concatTuple {{c1}} {{c2}} = Concat (concatTup c1 c2)

/**
 * Atoms are a shared, uncoordinated, synchronous reference to an immutable value.
 */
pub
opaque type Atom a = AtomicReference a

/**
 * Creates a new Atom to hold x.
 * Should *not* be used to hold a mutable value.
 */
pub
atom : a -> Atom a
atom x = Atom AtomicReference#new(x)

/**
 * Returns the value inside this Atom.
 */
pub
deref : Atom a -> a
deref (Atom a) = a#get()

/**
 * Resets the value of this Atom to x, discarding the old value.
 * Returns x.
 */
pub
reset : a -> Atom a -> a
reset x (Atom a) =
  a#set(x)
  x

/**
 * Swaps the value of this atom by applying a function to the old value.
 * The function *should be free of side effects* as it may be executed
 * multiple times.
 */
pub
swap : (a -> a) -> Atom a -> a
swap f (Atom a) = Core#swapAtom(a, f)

/**
 * Low-level function that receives the old value, the new value and attempts
 * to set the atom to new if old matches.
 * Returns true if it succeeded.
 * Always prefer `swap` over `compareAndSet`.
 */
pub
compareAndSet : a -> a -> Atom a -> Boolean
compareAndSet old new (Atom atm) = atm#compareAndSet(old, new)

equalsAtom : Equals a -> Atom a -> Atom a -> Boolean
equalsAtom (Equals eq) x y = eq (deref x) (deref y)

pub instance
eqAtom : {{ Equals a }} -> Equals (Atom a)
eqAtom {{eq}} = Equals (equalsAtom eq)

pub instance
showAtom : {{ Show a }} -> Show (Atom a)
showAtom {{Show sh}} = Show \atm -> format "(Atom %s)" [sh (deref atm)]

/**
 * Executes the function for every number from begin (inclusive) to end (exclusive).
 * This is a specialized version of `List.forEach (begin .. end) f`.
 */
pub
forEachRange : Int64 -> Int64 -> (Int64 -> a) -> Unit
forEachRange begin end f = Core#eachRange(begin, end, 1, f)

/**
 * Executes the function starting at begin (inclusive) ending in end (exclusive) with the specified step.
 */
pub
forEachStep : Int64 -> Int64 -> Int32 -> (Int64 -> a) -> Unit
forEachStep begin end step f = Core#eachRange(begin, end, step, f)

/**
 * Executes the function for every number from begin (inclusive) to end (exclusive).
 * The for breaks if the function returns a number < 0.
 */
pub
forEachBreak : Int64 -> Int64 -> (Int64 -> Int32) -> Unit
forEachBreak begin end f = Core#eachRangeBreak(begin, end, f)

/**
 * Types that can generate a list over a range.
 */
pub+
opaque type Range a =
  { range: a -> a -> List a
  , rangeInclusive: a -> a -> List a
  }

/**
 * Returns a list starting at begin (inclusive) and ending at end (exclusive).
 */
pub
(..) : {{ Range a }} -> a -> a -> List a
(..) {{Range r}} begin end = r.range begin end

/**
 * Returns a list starting at begin (inclusive) and ending at end (inclusive).
 */
pub
(...) : {{ Range a }} -> a -> a -> List a
(...) {{Range r}} begin end = r.rangeInclusive begin end

pub instance
rangeInt32 : Range Int32
rangeInt32 =
  Range
    { range: \begin end -> Core#listIntRange(begin, end)
    , rangeInclusive: \begin end -> Core#listIntRange(begin, end + 1)
    }

pub instance
rangeInt64 : Range Int64
rangeInt64 =
  Range
    { range: \begin end -> Core#listLongRange(begin, end)
    , rangeInclusive: \begin end -> Core#listLongRange(begin, end + 1L)
    }

pub instance
rangeFloat32 : Range Float32
rangeFloat32 =
  Range
    { range: \begin end -> Core#listFloatRange(begin, end)
    , rangeInclusive: \begin end -> Core#listFloatRange(begin, end + 1.0F)
    }

pub instance
rangeFloat64 : Range Float64
rangeFloat64 =
  Range
    { range: \begin end -> Core#listDoubleRange(begin, end)
    , rangeInclusive: \begin end -> Core#listDoubleRange(begin, end + 1.0)
    }

pub instance
rangeChar : Range Char
rangeChar =
  Range
    { range: \begin end -> Core#listCharRange(begin, end)
    , rangeInclusive: \begin end -> Core#listCharRange(begin, Core#intToChar(Core#charToInt(end) + 1))
    }