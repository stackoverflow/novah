// The core functions of the language.
// Imported automatically in every module.
module novah.core

foreign import io.lacuna.bifurcan.IList
foreign import io.lacuna.bifurcan.ISet
foreign import novah.Core
foreign import novah.collections.Record
foreign import novah.range.BigDecimalRange
foreign import novah.range.BigDecimalOpenRange
foreign import novah.range.BigIntRange
foreign import novah.range.BigIntOpenRange
foreign import novah.range.CharRange
foreign import novah.range.CharOpenRange
foreign import novah.range.DoubleRange
foreign import novah.range.DoubleOpenRange
foreign import novah.range.FloatRange
foreign import novah.range.FloatOpenRange
foreign import novah.range.IntRange
foreign import novah.range.IntOpenRange
foreign import novah.range.LongRange
foreign import novah.range.LongOpenRange
foreign import java.util.concurrent.atomic.AtomicReference
foreign import java.lang.AssertionError
foreign import java.lang.Class
foreign import java.lang.Math
foreign import java.lang.System
foreign import java.time.Duration
foreign import java.time.Instant
foreign import java.time.temporal.Temporal

// A 32-bits Integer
pub
typealias Int = Int32

// Coerce parameter x from type a to b.
// This is extremely unsafe and should be used only
// when sure both types are compatible, otherwise
// a runtime exception will be thrown.
pub
unsafeCast : a -> b
unsafeCast x = x as b

// Negates a boolean value.
pub
not : Boolean -> Boolean
not b = Core#not(b)

// Returns the exclusive disjunction of p and q.
pub
xor : Boolean -> Boolean -> Boolean
xor p q = Core#xor(p, q)

// Returns its argument unmodified.
pub
identity : a -> a
identity x = x

// Flips the arguments of a 2-arguments function.
pub
flip : (a -> b -> c) -> (b -> a -> c)
flip f y x = f x y

// Takes two parameters and returns the first, ignoring the second.
pub
const : a -> b -> a
const x _ = x

// The railway operator.
// Applies function f to x.
// Used to minimize parentheses and have a
// more intuitive order of execution:
//
// `1 .. 100 |> List.reverse |> List.map (_ * 10)`
// instead of
// `List.map (_ * 10) (List.reverse (1 .. 100))`
pub
(|>) : a -> (a -> b) -> b
(|>) x f = f x

// The reverse of the `|>` (railway operator).
// Applies function f to x.
// Used to minimize parentheses:
//
// `List.map (_ * 10) <| List.reverse <| 1 .. 100`
// instead of
// `List.map (_ * 10) (List.sort (1 .. 100))`
pub
(<|) : (a -> b) -> a -> b
(<|) f x = f x

// Forward function composition operator: `(f >> g) x = g (f x)`
pub
(>>) : (a -> b) -> (b -> c) -> (a -> c)
(>>) f g x = g (f x)

// Backward function composition operator: `(f << g) x = f (g x)`
pub
(<<) : (b -> c) -> (a -> b) -> (a -> c)
(<<) f g x = f (g x)

// Returns true if the 2 references point to the same object.
// This is the same as Java's ==
pub
(===) : a -> a -> Boolean
(===) x y = Core#equivalentObject(x, y)

// Returns true if the 2 objects *do not* point to the same object.
// This is the same as Java's !=
pub
(!==) : a -> a -> Boolean
(!==) x y = Core#not(Core#equivalentObject(x, y))

// Logical `and` operator.
// Returns true if both conditions are true.
// This operator will short circuit if fully applied.
pub
(&&) : Boolean -> Boolean -> Boolean
(&&) cond1 cond2 = Core#and(cond1, cond2)

// Logical `or` operator.
// Returns true if at least one of the conditions is true.
// This operator will short circuit if fully applied.
pub
(||) : Boolean -> Boolean -> Boolean
(||) cond1 cond2 = Core#or(cond1, cond2)

// Prints x to stdout and appends a new line.
pub
println : a -> Unit
println x = System#-out#println(x as Object)

// Prints x to the stdout.
pub
print : a -> Unit
print x = System#-out#print(x as Object)

// Prints x to stderr and appends a new line.
pub
printlnErr : a -> Unit
printlnErr x = System#-err#println(x as Object)

// Prints x to the stderr.
pub
printErr : a -> Unit
printErr x = System#-err#print(x as Object)

// Converts a value to String using the
// native Java toString method.
pub
toString : a -> String
toString x = (x as Object)#toString()

// Throws an exception stating that this code is still undergoing implementation.
// Should be used a placeholder for future code.
pub
todo : String -> a
todo msg = throw AssertionError#new(format "Not implemented: %s" [msg] as Object)

// Returns the char at index for this string if it exists.
// Negative indexes will start from the end of the string.
// *Unsafe*: Will throw an exception if the index is out of bounds.
pub
(!) : String -> Int32 -> Char
(!) str idx = Core#stringGet(idx, str)

// Sets the value of this list at the specified index to x.
// *Unsafe*: Will throw a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
// Runtime: ~O(1)
pub
setAt : Int32 -> a -> List a -> List a
setAt index x list = list#set(index#longValue(), x)

// Updates the value of this list at the specified index by applying function f to the old value.
// *Unsafe*: Will throw a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
// Runtime: ~O(1)
pub
updateAt : Int32 -> (a -> a) -> List a -> List a
updateAt index f list = list#set(index#longValue(), f list.[index])

// Appends x to the beginning of this list.
// Runtime: ~O(1)
pub
addFirst : a -> List a -> List a
addFirst x list = list#addFirst(x)

// Appends x to the end of this list.
// Runtime: ~O(1)
pub
addLast : a -> List a -> List a
addLast x list = list#addLast(x)

// Removes the first element of this list.
// Runtime: ~O(1)
pub
removeFirst : List a -> List a
removeFirst list = list#removeFirst()

// Removes the last element of this list.
// Runtime: ~O(1)
pub
removeLast : List a -> List a
removeLast list = list#removeLast()

// Gets the element of the array at the specified index.
// Negative indexes will start from the end of the array.
// *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
// Runtime: O(1)
pub
aget : Int32 -> Array a -> a
aget index arr = Core#arrayGet(index, arr)

// Sets the element of the array at the specified index.
// *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
// Runtime: O(1)
pub
aset : Int32 -> a -> Array a -> Unit
aset index x arr = Core#setArray(index, x, arr)

// Updates the element of the array at the specified index by applying this function
// to the old value.
// Negative indexes will start from the end of the array.
// *Unsafe*: Will thrown a `java.lang.IndexOutOfBoundsException` if the index doesn't exist.
// Runtime: O(1)
pub
aupdate : Int32 -> (a -> a) -> Array a -> Unit
aupdate index updateFn arr = Core#setArray(index, updateFn Core#arrayGet(index, arr), arr)

// Creates an array of the specified class and size.
pub
arrayOf : Class a -> Int32 -> Array a
arrayOf clazz length = Core#mkArray(clazz, length)

// Returns a formatted string using the specified format string and arguments.
// See `java.util.Formatter` for format explanation.
pub
format : String -> List a -> String
format str list = String#format(str, list#toArray())

// Prints the formatted string to stdout.
pub
printfln : String -> List a -> Unit
printfln form args = println (format form args)

// Returns the value contained in this option
// or the default value.
pub
(?:) : Option a -> a -> a
(?:) opt def =
  case opt of
    Some x -> x
    None -> def

// Extracts the value out of this option.
// *Unsafe*: Will thrown an exception if the option is empty.
// The `!!` syntactic sugar can be used instead,
// but this function still needs to be in scope.
pub
unwrapOption : Option a -> a
unwrapOption = case _ of
  Some x -> x
  None -> throw AssertionError#new("Empty Option" as Object)

// Threads optional values together stopping as soon as
// the option is empty.
// This is a flipped version of `Option.flatMap`.
// Ex.:
// ```novah
// List.nth 1 [[1, 2], [3, 4]] ? List.nth 5 ?: 0
// ```
pub
(?) : Option a -> (a -> Option b) -> Option b
(?) opt fun = case opt of
  Some x -> fun x
  None -> None

// Maps the function inside the option if it's not empty.
// This is a flipped version of `Option.map`.
// Ex.:
// ```novah
// Some [1, 2, 3] ?? List.size
// ```
pub
(??) : Option a -> (a -> b) -> Option b
(??) opt fun = case opt of
  Some x -> Some (fun x)
  None -> None

// Represents a computation that can fail.
// Should be used to represent errors instead of exceptions.
pub+
type Result ok err
  = Ok ok
  | Err err

// Atoms are a shared, uncoordinated, synchronous reference to an immutable value.
pub
type Atom a = Atom (AtomicReference a)

// Creates a new Atom to hold x.
// Should *not* be used to hold a mutable value.
pub
atom : a -> Atom a
atom x = Atom AtomicReference#new(x)

// Returns the value inside this Atom.
pub
deref : Atom a -> a
deref (Atom a) = a#get()

// Resets the value of this Atom to x, discarding the old value.
// Returns x.
pub
reset : a -> Atom a -> a
reset x (Atom a) =
  a#set(x)
  x

// Resets the value of this Atom to x, discarding the old value.
pub
(:=) : Atom a -> a -> Unit
(:=) (Atom a) x = a#set(x)

// Swaps the value of this atom by applying a function to the old value.
// The function *should be free of side effects* as it may be executed
// multiple times.
pub
swap : (a -> a) -> Atom a -> a
swap f (Atom a) = Core#swapAtom(a, f)

// Swaps the value of this atom by applying a function to the old value.
// The function *should be free of side effects* as it may be executed
// multiple times.
pub
(::=) : Atom a -> (a -> a) -> Unit
(::=) (Atom a) f =
  Core#swapAtom(a, f)
  ()

// Low-level function that receives the old value, the new value and attempts
// to set the atom to new if old matches.
// Returns true if it succeeded.
// Always prefer `swap` over `compareAndSet`.
pub
compareAndSet : a -> a -> Atom a -> Boolean
compareAndSet old new (Atom atm) = atm#compareAndSet(old, new)

// Runs the function and returns the result and the time it took.
pub
withTime : (Unit -> a) -> Tuple a Duration
withTime f =
  let start = Instant#now()
  let res = f ()
  let end = Instant#now()
  res ; Duration#between(start as Temporal, end as Temporal)

// The ordering type represents the outcome
// of comparing 2 values:
//
// GT -> bigger than
// EQ -> equals
// LT -> less than
pub+
type Ordering = GT | LT | EQ

// A Tuple containing two values.
pub+
type Tuple a b = Tuple a b

// Returns the first element of this tuple.
// Runtime: O(1)
pub
fst : Tuple a b -> a
fst (Tuple x _) = x

// Returns the second element of this tuple.
// Runtime: O(1)
pub
snd : Tuple a b -> b
snd (Tuple _ x) = x

// The type of things that have size.
pub+
type Sized a = Sized (a -> Int32)

// Returns the length of this sized value.
pub
len : {{ Sized a }} -> a -> Int32
len {{Sized size}} x = size x

pub instance
sizedString : Sized String
sizedString = Sized \(str : String) -> str#length()

pub instance
sizedList : Sized (List a)
sizedList = Sized \(list : List a) -> list#size()#intValue()

pub instance
sizedSet : Sized (Set a)
sizedSet = Sized \(set : Set a) -> set#size()#intValue()

pub instance
sizedMap : Sized (Map k v)
sizedMap = Sized \(map : Map k v) -> map#size()#intValue()

pub instance
sizedArray : Sized (Array a)
sizedArray = Sized \arr -> Core#getArrayLength(arr)

pub instance
sizedByteArray : Sized ByteArray
sizedByteArray = Sized \arr -> Core#byteArraySize(arr)

pub instance
sizedInt16Array : Sized Int16Array
sizedInt16Array = Sized \arr -> Core#shortArraySize(arr)

pub instance
sizedInt32Array : Sized Int32Array
sizedInt32Array = Sized \arr -> Core#intArraySize(arr)

pub instance
sizedInt64Array : Sized Int64Array
sizedInt64Array = Sized \arr -> Core#longArraySize(arr)

pub instance
sizedFloat32Array : Sized Float32Array
sizedFloat32Array = Sized \arr -> Core#floatArraySize(arr)

pub instance
sizedFloat64Array : Sized Float64Array
sizedFloat64Array = Sized \arr -> Core#doubleArraySize(arr)

pub instance
sizedBooleanArray : Sized BooleanArray
sizedBooleanArray = Sized \arr -> Core#booleanArraySize(arr)

pub instance
sizedCharArray : Sized CharArray
sizedCharArray = Sized \arr -> Core#charArraySize(arr)

// The type of things that can be concatenated.
pub+
type Concat a = Concat (a -> a -> a)

// Concatenate 2 concatenable values together.
pub
(++) : {{ Concat a }} -> a -> a -> a
(++) {{Concat concat}} x y = concat x y

pub instance
concatString : Concat String
concatString = Concat \s s2 -> (s : String)#concat(s2)

pub instance
concatList : Concat (List a)
concatList = Concat \v v2 -> (v : List a)#concat(v2 as IList a) as List a

pub instance
concatSet : Concat (Set a)
concatSet = Concat \s s2 -> (s : Set a)#union(s2 as ISet a)

concatOption_ : Concat a -> Option a -> Option a -> Option a
concatOption_ (Concat concat) =
  case _, _ of
    Some x, Some y -> Some (concat x y)
    _, _ -> None

pub instance
concatOption : {{ Concat a }} -> Concat (Option a)
concatOption {{ap}} = Concat (concatOption_ ap)

concatTup : Concat a -> Concat b -> Tuple a b -> Tuple a b -> Tuple a b
concatTup (Concat c1) (Concat c2) (Tuple x y) (Tuple x2 y2) = Tuple (c1 x x2) (c2 y y2)

pub instance
concatTuple : {{ Concat a }} -> {{ Concat b }} -> Concat (Tuple a b)
concatTuple {{c1}} {{c2}} = Concat (concatTup c1 c2)

// The type of things that can be added together
// using the + operator.
pub+
type Plus a =
  Plus
    { plus : a -> a -> a
    , identity : a
    }

// Adds x and y.
pub
(+) : {{ Plus a }} -> a -> a -> a
(+) {{Plus plus}} x y = plus.plus x y

pub instance
plusInt32 : Plus Int32
plusInt32 =
  Plus
    { plus: \(x : Int32) y -> Core#sum(x, y)
    , identity: 0
    }

pub instance
plusInt64 : Plus Int64
plusInt64 =
  Plus
    { plus: \(x : Int64) y -> Core#sum(x, y)
    , identity: 0L
    }

pub instance
plusFloat32 : Plus Float32
plusFloat32 =
  Plus
    { plus: \(x : Float32) y -> Core#sum(x, y)
    , identity: 0.0F
    }

pub instance
plusFloat64 : Plus Float64
plusFloat64 =
  Plus
    { plus: \(x : Float64) y -> Core#sum(x, y)
    , identity: 0.0
    }

pub instance
plusBigInt : Plus BigInteger
plusBigInt =
  Plus
    { plus: \(x : BigInteger) y -> x#add(y)
    , identity: 0N
    }

pub instance
plusBigDec : Plus BigDecimal
plusBigDec =
  Plus
    { plus: \(x : BigDecimal) y -> x#add(y)
    , identity: 0M
    }

plusTup : Plus a -> Plus b -> Tuple a b -> Tuple a b -> Tuple a b
plusTup (Plus p1) (Plus p2) (Tuple x1 y1) (Tuple x2 y2) = Tuple (p1.plus x1 x2) (p2.plus y1 y2)

pub instance
plusTuple : {{ Plus a }} -> {{ Plus b }} -> Plus (Tuple a b)
plusTuple {{(Plus p1) as plusp1}} {{(Plus p2) as plusp2}} =
  Plus
    { plus: plusTup plusp1 plusp2
    , identity: Tuple p1.identity p2.identity
    }

// The type of things that can be subtracted
// using the - operator.
pub+
type Minus a = Minus (a -> a -> a)

// Subtracts x and y.
pub
(-) : {{ Minus a }} -> a -> a -> a
(-) {{Minus minus}} x y = minus x y

pub instance
minusInt32 : Minus Int32
minusInt32 = Minus \(x : Int32) y -> Core#sub(x, y)

pub instance
minusInt64 : Minus Int64
minusInt64 = Minus \(x : Int64) y -> Core#sub(x, y)

pub instance
minusFloat32 : Minus Float32
minusFloat32 = Minus \(x : Float32) y -> Core#sub(x, y)

pub instance
minusFloat64 : Minus Float64
minusFloat64 = Minus \(x : Float64) y -> Core#sub(x, y)

pub instance
minusBigInt : Minus BigInteger
minusBigInt = Minus \(x : BigInteger) y -> x#subtract(y)

pub instance
minusBigDec : Minus BigDecimal
minusBigDec = Minus \(x : BigDecimal) y -> x#subtract(y)

minusTup : Minus a -> Minus b -> Tuple a b -> Tuple a b -> Tuple a b
minusTup (Minus m1) (Minus m2) (Tuple x1 y1) (Tuple x2 y2) = Tuple (m1 x1 x2) (m2 y1 y2)

pub instance
minusTuple : {{ Minus a }} -> {{ Minus b }} -> Minus (Tuple a b)
minusTuple {{m1}} {{m2}} = Minus (minusTup m1 m2)

// The type of things that can be multiplied together
// using the * operator.
pub+
type Mult a =
  Mult
    { mult : a -> a -> a
    , identity : a
    }

// Multiplies x and y.
pub
(*) : {{ Mult a }} -> a -> a -> a
(*) {{Mult mult}} x y = mult.mult x y

pub instance
multInt32 : Mult Int32
multInt32 =
  Mult
    { mult: \(x : Int32) y -> Core#mult(x, y)
    , identity: 1
    }

pub instance
multInt64 : Mult Int64
multInt64 =
  Mult
    { mult: \(x : Int64) y -> Core#mult(x, y)
    , identity: 1L
    }

pub instance
multFloat32 : Mult Float32
multFloat32 =
  Mult
    { mult: \(x : Float32) y -> Core#mult(x, y)
    , identity: 1.0F
    }

pub instance
multFloat64 : Mult Float64
multFloat64 =
  Mult
    { mult: \(x : Float64) y -> Core#mult(x, y)
    , identity: 1.0
    }

pub instance
multBigInt : Mult BigInteger
multBigInt =
  Mult
    { mult: \(x : BigInteger) y -> x#multiply(y)
    , identity: 1N
    }

pub instance
multBigDec : Mult BigDecimal
multBigDec =
  Mult
    { mult: \(x : BigDecimal) y -> x#multiply(y)
    , identity: 1M
    }

multTup : Mult a -> Mult b -> Tuple a b -> Tuple a b -> Tuple a b
multTup (Mult p1) (Mult p2) (Tuple x1 y1) (Tuple x2 y2) = Tuple (p1.mult x1 x2) (p2.mult y1 y2)

pub instance
multTuple : {{ Mult a }} -> {{ Mult b }} -> Mult (Tuple a b)
multTuple {{(Mult p1) as multp1}} {{(Mult p2) as multp2}} =
  Mult
    { mult: multTup multp1 multp2
    , identity: Tuple p1.identity p2.identity
    }

// The type of things that can be divided
// using the / operator.
pub+
type Divide a = Divide (a -> a -> a)

// Divides x by y.
pub
(/) : {{ Divide a }} -> a -> a -> a
(/) {{Divide divide}} x y = divide x y

pub instance
divideInt32 : Divide Int32
divideInt32 = Divide \(x : Int32) y -> Core#div(x, y)

pub instance
divideInt64 : Divide Int64
divideInt64 = Divide \(x : Int64) y -> Core#div(x, y)

pub instance
divideFloat32 : Divide Float32
divideFloat32 = Divide \(x : Float32) y -> Core#div(x, y)

pub instance
divideFloat64 : Divide Float64
divideFloat64 = Divide \(x : Float64) y -> Core#div(x, y)

pub instance
divideBigInt : Divide BigInteger
divideBigInt = Divide \(x : BigInteger) y -> x#divide(y)

pub instance
divideBigDec : Divide BigDecimal
divideBigDec = Divide \(x : BigDecimal) y -> x#divide(y)

divideTup : Divide a -> Divide b -> Tuple a b -> Tuple a b -> Tuple a b
divideTup (Divide m1) (Divide m2) (Tuple x1 y1) (Tuple x2 y2) = Tuple (m1 x1 x2) (m2 y1 y2)

pub instance
divideTuple : {{ Divide a }} -> {{ Divide b }} -> Divide (Tuple a b)
divideTuple {{m1}} {{m2}} = Divide (divideTup m1 m2)

// The type of things that supports exponentiation
// using the ^ operator
pub+
type Exponential a = Exponential (a -> Int32 -> a)

// Returns x raised to the power of y.
pub
(^) : {{ Exponential a }} -> a -> Int32 -> a
(^) {{Exponential exp}} x y = exp x y

pub instance
expFloat64 : Exponential Float64
expFloat64 = Exponential \x (y : Int32) -> Math#pow(x, y#doubleValue())

pub instance
expBigInteger : Exponential BigInteger
expBigInteger = Exponential \(x : BigInteger) y -> x#pow(y)

pub instance
expBigDecimal : Exponential BigDecimal
expBigDecimal = Exponential \(x : BigDecimal) y -> x#pow(y)

// The type of things that have a String representation.
pub+
type Show a = Show (a -> String)

// Converts this value to a String.
pub
show : {{ Show a }} -> a -> String
show {{Show sh}} x = sh x

// Prints x to stdout and appends a new line.
// Transforms the argument to a String using `show` first.
pub
printlnShow : {{ Show a }} -> a -> Unit
printlnShow {{Show sh}} x = println (sh x)

// Prints x to stdout.
// Transforms the argument to a String using `show` first.
pub
printShow : {{ Show a }} -> a -> Unit
printShow {{Show sh}} x = print (sh x)

pub instance
showString : Show String
showString = Show identity

pub instance
showByte : Show Byte
showByte = Show toString

pub instance
showInt16 : Show Int16
showInt16 = Show toString

pub instance
showInt32 : Show Int32
showInt32 = Show toString

pub instance
showInt64 : Show Int64
showInt64 = Show toString

pub instance
showFloat32 : Show Float32
showFloat32 = Show toString

pub instance
showFloat64 : Show Float64
showFloat64 = Show toString

pub instance
showChar : Show Char
showChar = Show toString

pub instance
showBoolean : Show Boolean
showBoolean = Show toString

pub instance
showBigInt : Show BigInteger
showBigInt = Show toString

pub instance
showBigDec : Show BigDecimal
showBigDec = Show toString

pub instance
showObject : Show Object
showObject = Show toString

showOpt : Show a -> Option a -> String
showOpt (Show sh) =
  case _ of
    Some x -> format "(Some %s)" [sh x]
    None -> "None"

pub instance
showOption : {{ Show a }} -> Show (Option a)
showOption {{s}} = Show (showOpt s)

pub instance
showList : {{ Show a }} -> Show (List a)
showList {{Show sh}} = Show Core#toStringList(_, sh)

pub instance
showSet : {{ Show a }} -> Show (Set a)
showSet {{Show sh}} = Show Core#toStringSet(_, sh)

pub instance
showArray : {{ Show a }} -> Show (Array a)
showArray {{Show sh}} = Show Core#toStringArray(_, sh)

pub instance
showOrdering : Show Ordering
showOrdering = Show toString

showRes : Show ok -> Show err -> Result ok err -> String
showRes (Show s1) (Show s2) =
  case _ of
    Ok x -> format "(Ok %s)" [s1 x]
    Err x -> format "(Err %s)" [s2 x]

pub instance
showResult : {{ Show ok }} -> {{ Show err }} -> Show (Result ok err)
showResult {{s1}} {{s2}} = Show (showRes s1 s2)

pub instance
showAtom : {{ Show a }} -> Show (Atom a)
showAtom {{Show sh}} = Show \atm -> format "(Atom %s)" [sh (deref atm)]

showTup : Show a -> Show b -> Tuple a b -> String
showTup (Show s1) (Show s2) (Tuple x y) = format "(%s, %s)" [s1 x, s2 y]

pub instance
showTuple : {{ Show a }} -> {{ Show b }} -> Show (Tuple a b)
showTuple {{s1}} {{s2}} = Show (showTup s1 s2)

pub instance
showRange : {{ Show a }} -> Show (Range a)
showRange {{_}} = Show toString

// The type of things that support equality comparison.
pub+
type Equals a = Equals (a -> a -> Boolean)

// Returns true if the two values are equal.
pub
(==) : {{ Equals a }} -> a -> a -> Boolean
(==) {{Equals eq}} x y = eq x y

// Returns true if the two values are *not* equal.
pub
(!=) : {{ Equals a }} -> a -> a -> Boolean
(!=) {{Equals eq}} x y = not (eq x y)

pub instance
eqByte : Equals Byte
eqByte = Equals \(x : Byte) y -> Core#equivalent(x, y)

pub instance
eqInt16 : Equals Int16
eqInt16 = Equals \(x : Int16) y -> Core#equivalent(x, y)

pub instance
eqInt32 : Equals Int32
eqInt32 = Equals \(x : Int32) y -> Core#equivalent(x, y)

pub instance
eqInt64 : Equals Int64
eqInt64 = Equals \(x : Int64) y -> Core#equivalent(x, y)

pub instance
eqFloat32 : Equals Float32
eqFloat32 = Equals \(x : Float32) y -> Core#equivalent(x, y)

pub instance
eqFloat64 : Equals Float64
eqFloat64 = Equals \(x : Float64) y -> Core#equivalent(x, y)

pub instance
eqChar : Equals Char
eqChar = Equals \(x : Char) y -> Core#equivalent(x, y)

equalsBoolean : Boolean -> Boolean -> Boolean
equalsBoolean =
  case _, _ of
    true, true -> true
    false, false -> true
    _, _ -> false

pub instance
eqBoolean : Equals Boolean
eqBoolean = Equals equalsBoolean

pub instance
eqString : Equals String
eqString = Equals \(x : String) y -> x#equals((y : String) as Object)

pub instance
eqBigInt : Equals BigInteger
eqBigInt = Equals \(x : BigInteger) y -> x#equals(y as Object)

pub instance
eqBigDec : Equals BigDecimal
eqBigDec = Equals \(x : BigDecimal) y -> x#equals(y as Object)

pub instance
eqList : {{ Equals a }} -> Equals (List a)
eqList {{Equals eq}} = Equals \x y -> Core#equalsList(x, y, eq)

pub instance
eqSet : {{ Equals a }} -> Equals (Set a)
eqSet {{Equals eq}} = Equals \x y -> Core#equalsSet(x, y, eq)

pub instance
eqArray : {{ Equals a }} -> Equals (Array a)
eqArray {{Equals eq}} = Equals \x y -> Core#equalsArray(x, y, eq)

equalsOption : Equals a -> Option a -> Option a -> Boolean
equalsOption (Equals eq) =
  case _, _ of
    Some x, Some y -> eq x y
    None, None -> true
    _, _ -> false

pub instance
eqOption : {{ Equals a }} -> Equals (Option a)
eqOption {{eq}} = Equals (equalsOption eq)

pub instance
eqObject : Equals Object
eqObject = Equals \(x : Object) y -> x#equals(y)

equalsOrdering : Ordering -> Ordering -> Boolean
equalsOrdering =
  case _, _ of
    GT, GT -> true
    EQ, EQ -> true
    LT, LT -> true
    _, _ -> false

pub instance
eqOrdering : Equals Ordering
eqOrdering = Equals equalsOrdering

equalsResult : Equals ok -> Equals err -> Result ok err -> Result ok err -> Boolean
equalsResult (Equals eq1) (Equals eq2) =
  case _, _ of
    Ok x, Ok y -> eq1 x y
    Err x, Err y -> eq2 x y
    _, _ -> false

pub instance
eqResult : {{ Equals ok }} -> {{ Equals err }} -> Equals (Result ok err)
eqResult {{eq1}} {{eq2}} = Equals (equalsResult eq1 eq2)

equalsAtom : Equals a -> Atom a -> Atom a -> Boolean
equalsAtom (Equals eq) x y = eq (deref x) (deref y)

pub instance
eqAtom : {{ Equals a }} -> Equals (Atom a)
eqAtom {{eq}} = Equals (equalsAtom eq)

equalsTuple : Equals a -> Equals b -> Tuple a b -> Tuple a b -> Boolean
equalsTuple (Equals eq1) (Equals eq2) (Tuple x y) (Tuple x2 y2) = eq1 x x2 && eq2 y y2

pub instance
eqTuple : {{ Equals a }} -> {{ Equals b }} -> Equals (Tuple a b)
eqTuple {{eq1}} {{eq2}} = Equals (equalsTuple eq1 eq2)

pub instance
equalsRange : {{ Equals a }} -> Equals (Range a)
equalsRange {{_}} = Equals \(one : Range a) (other : Range a) -> (one as Object)#equals(other as Object)

// Compare if the two records are equals
// according to Java's equality.
pub
recordEquals : { | r } -> { | r } -> Boolean
recordEquals r1 r2 = (r1 as Record)#equals(r2 as Object)

// The type of things that can contain other values.
// The first type variable is the type of the contained value,
// the second is the type of the container itself.
// Ex.: Contained a (List a)
pub+
type Contained a fa = Contained (Equals a) (a -> fa -> Boolean)

// Returns true if x is inside the container.
pub
isIn : {{ Contained a fa }} -> a -> fa -> Boolean
isIn {{Contained _ con}} x container = con x container

// Returns true if x is *not* inside the container.
pub
notIn : {{ Contained a fa }} -> a -> fa -> Boolean
notIn {{Contained _ con}} x container = not (con x container)

pub instance
containedCharString : Contained Char String
containedCharString =
  Contained eqChar \c (str : String) -> str#indexOf(Core#charToInt(c)) >= 0

pub instance
containedString : Contained String String
containedString =
  Contained eqString \(s : String) (str : String) -> str#indexOf(s) >= 0

pub instance
containedSet : {{ Equals a }} -> Contained a (Set a)
containedSet {{eq}} = Contained eq \x (s : Set a) -> s#contains(x)

pub instance
containedList : {{ Equals a }} -> Contained a (List a)
containedList {{(Equals eq) as equals}} =
  Contained equals \x l -> Core#findList(eq x, l)#isPresent()

pub instance
containedOption : {{ Equals a }} -> Contained a (Option a)
containedOption {{(Equals eq) as equals}} =
  Contained equals \x -> case _ of
    Some v -> eq x v
    None -> false

pub instance
containedResult : {{ Equals a }} -> Contained a (Result a a)
containedResult {{(Equals eq) as equals}} =
  Contained equals \x -> case _ of
    Ok v -> eq x v
    Err v -> eq x v

pub instance
containedRange : {{ Equals a }} -> Contained a (Range a)
containedRange {{eq}} = Contained eq \x (r : Range a) -> r#contains(x)

// The type of things that can be ordered.
pub+
type Ord a = Ord (Equals a) { compare : a -> a -> Ordering }

// Returns the result of comparing two Ord instances.
pub
compare : {{ Ord a }} -> a -> a -> Ordering
compare {{Ord _ o}} x y = o.compare x y

// Returns true if x is greater than y.
pub
(>) : {{ Ord a }} -> a -> a -> Boolean
(>) {{Ord _ o}} x y =
  case o.compare x y of
    GT -> true
    _ -> false

// Returns true if x is smaller than y.
pub
(<) : {{ Ord a }} -> a -> a -> Boolean
(<) {{Ord _ o}} x y =
  case o.compare x y of
    LT -> true
    _ -> false

// Returns true if x is greater than or equal y.
pub
(>=) : {{ Ord a }} -> a -> a -> Boolean
(>=) {{Ord _ o}} x y =
  case o.compare x y of
    LT -> false
    _ -> true

// Returns true if x is smaller than or equal y.
pub
(<=) : {{ Ord a }} -> a -> a -> Boolean
(<=) {{Ord _ o}} x y =
  case o.compare x y of
    GT -> false
    _ -> true

pub instance
ordInt32 : Ord Int32
ordInt32 = Ord eqInt32 { compare: unsafeCast Core#compareInt(LT as Object, EQ as Object, GT as Object) }

pub instance
ordInt64 : Ord Int64
ordInt64 = Ord eqInt64 { compare: unsafeCast Core#compareLong(LT as Object, EQ as Object, GT as Object) }

pub instance
ordFloat64 : Ord Float64
ordFloat64 = Ord eqFloat64 { compare: unsafeCast Core#compareDouble(LT as Object, EQ as Object, GT as Object) }

pub instance
ordByte : Ord Byte
ordByte =
  Ord eqByte
    { compare:
      \(x : Byte) (y : Byte) ->
        let comp = unsafeCast Core#compareInt(LT as Object, EQ as Object, GT as Object)
        comp x#intValue() y#intValue()
    }

pub instance
ordInt16 : Ord Int16
ordInt16 =
  Ord eqInt16
    { compare:
      \(x : Int16) (y : Int16) ->
        let comp = unsafeCast Core#compareInt(LT as Object, EQ as Object, GT as Object)
        comp x#intValue() y#intValue()
    }

pub instance
ordFloat32 : Ord Float32
ordFloat32 =
  Ord eqFloat32
    { compare:
      \(x : Float32) (y : Float32) ->
        let comp = unsafeCast Core#compareDouble(LT as Object, EQ as Object, GT as Object)
        comp x#doubleValue() y#doubleValue()
    }

pub instance
ordChar : Ord Char
ordChar = Ord eqChar { compare: unsafeCast Core#compareChar(LT as Object, EQ as Object, GT as Object) }

compareBoolean : Boolean -> Boolean -> Ordering
compareBoolean =
  case _, _ of
    true, true -> EQ
    false, false -> EQ
    true, false -> GT
    false, true -> LT

pub instance
ordBoolean : Ord Boolean
ordBoolean = Ord eqBoolean { compare: compareBoolean }

pub instance
ordString : Ord String
ordString = Ord eqString { compare: unsafeCast Core#compareString(LT as Object, EQ as Object, GT as Object) }

compareOption : Ord a -> Option a -> Option a -> Ordering
compareOption (Ord _ o) =
  case _, _ of
    Some x, Some y -> o.compare x y
    Some _, None -> GT
    None, Some _ -> LT
    None, None -> EQ

compareBigInt : BigInteger -> BigInteger -> Ordering
compareBigInt x y = case x#compareTo(y) of
  0 -> EQ
  1 -> GT
  _ -> LT

pub instance
ordBigInt : Ord BigInteger
ordBigInt = Ord eqBigInt { compare: compareBigInt }

compareBigDec : BigDecimal -> BigDecimal -> Ordering
compareBigDec x y = case x#compareTo(y) of
  0 -> EQ
  1 -> GT
  _ -> LT

pub instance
ordBigDec : Ord BigDecimal
ordBigDec = Ord eqBigDec { compare: compareBigDec }

// Compares two options if their values are comparable.
// None values are always smaller then Some.
pub instance
ordOption : {{ Ord a }} -> Ord (Option a)
ordOption {{(Ord eq _) as ord}} = Ord (eqOption {{eq}}) { compare: compareOption ord }

// A type for some miscellaneous number operations.
pub+
type NumberOps a =
  NumberOps
    { remainder : a -> a -> a
    , even: a -> Boolean
    , min: a -> a -> a
    , max: a -> a -> a
    , abs: a -> a
    }

// Returns the remainder of dividing x by y.
pub
(%) : {{ NumberOps a }} -> a -> a -> a
(%) {{NumberOps r}} x y = r.remainder x y

pub instance
numberOpsInt32 : NumberOps Int32
numberOpsInt32 =
  NumberOps
    { remainder: \x y -> Core#intRemainder(x, y)
    , even: \x -> Core#intRemainder(x, 2) == 0
    , min: \(x : Int32) y -> Math#min(x, y)
    , max: \(x : Int32) y -> Math#max(x, y)
    , abs: \(x : Int32) -> Math#abs(x)
    }

pub instance
numberOpsInt64 : NumberOps Int64
numberOpsInt64 =
  NumberOps
    { remainder: \x y -> Core#longRemainder(x, y)
    , even: \x -> Core#longRemainder(x, 2L) == 0L
    , min: \(x : Int64) y -> Math#min(x, y)
    , max: \(x : Int64) y -> Math#max(x, y)
    , abs: \(x : Int64) -> Math#abs(x)
    }

pub instance
numberOpsFloat32 : NumberOps Float32
numberOpsFloat32 =
  NumberOps
    { remainder: \x y -> Core#floatRemainder(x, y)
    , even: \x -> Core#floatRemainder(x, 2F) == 0F
    , min: \(x : Float32) y -> Math#min(x, y)
    , max: \(x : Float32) y -> Math#max(x, y)
    , abs: \(x : Float32) -> Math#abs(x)
    }

pub instance
numberOpsFloat64 : NumberOps Float64
numberOpsFloat64 =
  NumberOps
    { remainder: \x y -> Core#doubleRemainder(x, y)
    , even: \x -> Core#doubleRemainder(x, 2.0) == 0.0
    , min: \(x : Float64) y -> Math#min(x, y)
    , max: \(x : Float64) y -> Math#max(x, y)
    , abs: \(x : Float64) -> Math#abs(x)
    }

pub instance
numberOpsBigInt : NumberOps BigInteger
numberOpsBigInt =
  NumberOps
    { remainder: \(x : BigInteger) y -> x#remainder(y)
    , even: \(x: BigInteger) -> x#mod(2N)#equals(0N as Object)
    , min: \(x : BigInteger) y -> x#min(y)
    , max: \(x : BigInteger) y -> x#max(y)
    , abs: \(x : BigInteger) -> x#abs()
    }

pub instance
numberOpsBigDec : NumberOps BigDecimal
numberOpsBigDec =
  NumberOps
    { remainder: \(x : BigDecimal) y -> x#remainder(y)
    , even: \(x: BigDecimal) -> x#remainder(2M)#equals(0M as Object)
    , min: \(x : BigDecimal) y -> x#min(y)
    , max: \(x : BigDecimal) y -> x#max(y)
    , abs: \(x : BigDecimal) -> x#abs()
    }

// Types that can be converted to numbers.
// Many of these conversions are unsafe like
// int64 -> int, String -> int, etc.
// Booleans are converted to 1 for true and 0 for false.
pub+
type ToNumber a =
  ToNumber
    { int : a -> Int32
    , int64 : a -> Int64
    , float32 : a -> Float32
    , float64 : a -> Float64
    }

// Converts this value to a 32-bit integer.
pub
int : {{ ToNumber a }} -> a -> Int32
int {{ToNumber t}} x = t.int x

// Converts this value to a 64-bit integer.
pub
int64 : {{ ToNumber a }} -> a -> Int64
int64 {{ToNumber t}} x = t.int64 x

// Converts this value to a 32-bit float.
pub
float32 : {{ ToNumber a }} -> a -> Float32
float32 {{ToNumber t}} x = t.float32 x

// Converts this value to a 64-bit float.
pub
float64 : {{ ToNumber a }} -> a -> Float64
float64 {{ToNumber t}} x = t.float64 x

pub instance
toNumberInt32 : ToNumber Int32
toNumberInt32 =
  ToNumber
    { int: identity
    , int64: \(n : Int32) -> n#longValue()
    , float32: \(n : Int32) -> n#floatValue()
    , float64: \(n : Int32) -> n#doubleValue()
    }

pub instance
toNumberInt64 : ToNumber Int64
toNumberInt64 =
  ToNumber
    { int: \(n : Int64) -> n#intValue()
    , int64: identity
    , float32: \(n : Int64) -> n#floatValue()
    , float64: \(n : Int64) -> n#doubleValue()
    }

pub instance
toNumberFloat32 : ToNumber Float32
toNumberFloat32 =
  ToNumber
    { int: \(n : Float32) -> n#intValue()
    , int64: \(n : Float32) -> n#longValue()
    , float32: identity
    , float64: \(n : Float32) -> n#doubleValue()
    }

pub instance
toNumberFloat64 : ToNumber Float64
toNumberFloat64 =
  ToNumber
    { int: \(n : Float64) -> n#intValue()
    , int64: \(n : Float64) -> n#longValue()
    , float32: \(n : Float64) -> n#floatValue()
    , float64: identity
    }

pub instance
toNumberChar : ToNumber Char
toNumberChar =
  ToNumber
    { int: Core#charToInt(_)
    , int64: \n -> Core#charToInt(n)#longValue()
    , float32: \n -> Core#charToInt(n)#floatValue()
    , float64: \n -> Core#charToInt(n)#doubleValue()
    }

pub instance
toNumberString : ToNumber String
toNumberString =
  ToNumber
    { int: Int32#parseInt(_)
    , int64: Int64#parseLong(_)
    , float32: Float32#parseFloat(_)
    , float64: Float64#parseDouble(_)
    }

pub instance
toNumberBoolean : ToNumber Boolean
toNumberBoolean =
  ToNumber
    { int: if _ then 1 else 0
    , int64: if _ then 1L else 0L
    , float32: if _ then 1.0F else 0.0F
    , float64: if _ then 1.0 else 0.0
    }

pub instance
toNumberBigInt : ToNumber BigInteger
toNumberBigInt =
  ToNumber
    { int: \(n : BigInteger) -> n#intValue()
    , int64: \(n : BigInteger) -> n#longValue()
    , float32: \(n : BigInteger) -> n#floatValue()
    , float64: \(n : BigInteger) -> n#doubleValue()
    }

pub instance
toNumberBigDec : ToNumber BigDecimal
toNumberBigDec =
  ToNumber
    { int: \(n : BigDecimal) -> n#intValue()
    , int64: \(n : BigDecimal) -> n#longValue()
    , float32: \(n : BigDecimal) -> n#floatValue()
    , float64: \(n : BigDecimal) -> n#doubleValue()
    }

// Represents a type that supports bitwise operations.
pub+
type BitOperator a =
  BitOperator
    { and : a -> a -> a
    , or : a -> a -> a
    , xor : a -> a -> a
    , not : a -> a
    , shiftLeft : a -> a -> a
    , shiftRight : a -> a -> a
    }

// Represents a type of a fixed size that supports bitwise operations.
pub+
type FixedSizeBitOperator a =
  FixedSizeBitOperator { unsignedShiftRight: a -> a -> a }

// Returns the bitwise and between x and y.
// Equivalent to Java's `&`.
pub
bitAnd : {{ BitOperator a }} -> a -> a -> a
bitAnd {{BitOperator b}} x y = b.and x y

// Returns the bitwise or between x and y.
// Equivalent to Java's `|`.
pub
bitOr : {{ BitOperator a }} -> a -> a -> a
bitOr {{BitOperator b}} x y = b.or x y

// Returns the bitwise xor between x and y.
// Equivalent to Java's `^`.
pub
bitXor : {{ BitOperator a }} -> a -> a -> a
bitXor {{BitOperator b}} x y = b.xor x y

// Returns the bit complement of x.
// Equivalent to Java's `~`.
pub
bitNot : {{ BitOperator a }} -> a -> a
bitNot {{BitOperator b}} x = b.not x

// Shifts `x` bitwise to the left by `amount`.
// Equivalent to Java's `<<`.
pub
bitShiftLeft : {{ BitOperator a }} -> a -> a -> a
bitShiftLeft {{BitOperator b}} x amount = b.shiftLeft x amount

// Shifts `x` bitwise to the right by `amount`.
// Equivalent to Java's `>>`.
pub
bitShiftRight : {{ BitOperator a }} -> a -> a -> a
bitShiftRight {{BitOperator b}} x amount = b.shiftRight x amount

// Shifts `x` bitwise to the right by `amount` (unsigned).
// Equivalent to Java's `>>>`.
pub
bitUnsignedShiftRight : {{ FixedSizeBitOperator a }} -> a -> a -> a
bitUnsignedShiftRight {{FixedSizeBitOperator b}} x amount = b.unsignedShiftRight x amount

pub instance
bitOperatorByte : BitOperator Byte
bitOperatorByte =
  BitOperator
    { and: \(x : Byte) (y : Byte) -> Core#bitAndInt(x#intValue(), y#intValue())#byteValue()
    , or: \(x : Byte) (y : Byte) -> Core#bitOrInt(x#intValue(), y#intValue())#byteValue()
    , xor: \(x : Byte) (y : Byte) -> Core#bitXorInt(x#intValue(), y#intValue())#byteValue()
    , shiftLeft: \(x : Byte) (y : Byte) -> Core#bitShiftLeftInt(x#intValue(), y#intValue())#byteValue()
    , shiftRight: \(x : Byte) (y : Byte) -> Core#bitShiftRightInt(x#intValue(), y#intValue())#byteValue()
    , not: \(x : Byte) -> Core#bitNotInt(x#intValue())#byteValue()
    }

pub instance
fixedSizeBitOperatorByte : FixedSizeBitOperator Byte
fixedSizeBitOperatorByte =
  FixedSizeBitOperator
    { unsignedShiftRight: \(x : Byte) (y : Byte) -> Core#unsignedBitShiftRightInt(x#intValue(), y#intValue())#byteValue() }

pub instance
bitOperatorInt16 : BitOperator Int16
bitOperatorInt16 =
  BitOperator
    { and: \(x : Int16) (y : Int16) -> Core#bitAndInt(x#intValue(), y#intValue())#shortValue()
    , or: \(x : Int16) (y : Int16) -> Core#bitOrInt(x#intValue(), y#intValue())#shortValue()
    , xor: \(x : Int16) (y : Int16) -> Core#bitXorInt(x#intValue(), y#intValue())#shortValue()
    , shiftLeft: \(x : Int16) (y : Int16) -> Core#bitShiftLeftInt(x#intValue(), y#intValue())#shortValue()
    , shiftRight: \(x : Int16) (y : Int16) -> Core#bitShiftRightInt(x#intValue(), y#intValue())#shortValue()
    , not: \(x : Int16) -> Core#bitNotInt(x#intValue())#shortValue()
    }

pub instance
fixedSizeBitOperatorInt16 : FixedSizeBitOperator Int16
fixedSizeBitOperatorInt16 =
  FixedSizeBitOperator
    { unsignedShiftRight: \(x : Int16) (y : Int16) -> Core#unsignedBitShiftRightInt(x#intValue(), y#intValue())#shortValue() }

pub instance
bitOperatorInt32 : BitOperator Int32
bitOperatorInt32 =
  BitOperator
    { and: \x y -> Core#bitAndInt(x, y)
    , or: \x y -> Core#bitOrInt(x, y)
    , xor: \x y -> Core#bitXorInt(x, y)
    , shiftLeft: \x y -> Core#bitShiftLeftInt(x, y)
    , shiftRight: \x y -> Core#bitShiftRightInt(x, y)
    , not: \x -> Core#bitNotInt(x)
    }

pub instance
fixedSizeBitOperatorInt32 : FixedSizeBitOperator Int32
fixedSizeBitOperatorInt32 =
  FixedSizeBitOperator
    { unsignedShiftRight: \x y -> Core#unsignedBitShiftRightInt(x, y) }

pub instance
bitOperatorInt64 : BitOperator Int64
bitOperatorInt64 =
  BitOperator
    { and: \x y -> Core#bitAndLong(x, y)
    , or: \x y -> Core#bitOrLong(x, y)
    , xor: \x y -> Core#bitXorLong(x, y)
    , shiftLeft: \x y -> Core#bitShiftLeftLong(x, y)
    , shiftRight: \x y -> Core#bitShiftRightLong(x, y)
    , not: \x -> Core#bitNotLong(x)
    }

pub instance
fixedSizeBitOperatorInt64 : FixedSizeBitOperator Int64
fixedSizeBitOperatorInt64 =
  FixedSizeBitOperator
    { unsignedShiftRight: \x y -> Core#unsignedBitShiftRightLong(x, y) }

pub instance
bitOperatorBigInt : BitOperator BigInteger
bitOperatorBigInt =
  BitOperator
    { and: \(x : BigInteger) y -> x#and(y)
    , or: \(x : BigInteger) y -> x#or(y)
    , xor: \(x : BigInteger) y -> x#xor(y)
    , shiftLeft: \(x : BigInteger) (y : BigInteger) -> x#shiftLeft(y#intValue())
    , shiftRight: \(x : BigInteger) (y : BigInteger) -> x#shiftRight(y#intValue())
    , not: \(x : BigInteger) -> x#not()
    }

// Types that can range over some values.
pub+
type Ranged a =
  Ranged
    { range : a -> a -> Range a
    , rangeOpen : a -> a -> Range a
    }

// Types that can range over some values with a step.
pub+
type RangedStep a =
  RangedStep
    { range : a -> a -> a -> Range a
    , rangeOpen : a -> a -> a -> Range a
    }

// Returns a range from begin (inclusive) to end (inclusive).
// If start > end the range will go down instead of up.
// Runtime: O(1)
pub
(..) : {{ Ranged a }} -> a -> a -> Range a
(..) {{Ranged r}} begin end = r.range begin end

// Returns a range from begin (inclusive) to end (exclusive).
// If start > end the range will go down instead of up.
// Runtime: O(1)
pub
(...) : {{ Ranged a }} -> a -> a -> Range a
(...) {{Ranged r}} begin end = r.rangeOpen begin end

// Returns a range between begin (inclusive) and end (inclusive) going step by step.
// Runtime: O(1)
pub
range : {{ RangedStep a }} -> a -> a -> a -> Range a
range {{RangedStep r}} start end step = r.range start end step

// Returns a range between begin (inclusive) and end (exclusive) going step by step.
// Runtime: O(1)
pub
rangeOpen : {{ RangedStep a }} -> a -> a -> a -> Range a
rangeOpen {{RangedStep r}} start end step = r.rangeOpen start end step

// Executes the function for every value in this range.
pub
forEachRange : Range a -> (a -> Unit) -> Unit
forEachRange ran fun = ran#foreach(fun)

// Returns a list with all the elements of this range.
pub
rangeToList : Range a -> List a
rangeToList r = r#toList()

// Returns a set with all the elements of this range.
pub
rangeToSet : Range a -> Set a
rangeToSet r = r#toSet()

// The starting value of this range.
pub
rangeStart : Range a -> a
rangeStart r = r#start()

// The ending value of this range.
pub
rangeEnd : Range a -> a
rangeEnd r = r#end()

pub instance
rangedInt32 : Ranged Int32
rangedInt32 =
  Ranged
    { range: \start end -> IntRange#new(start, end) as Range Int32
    , rangeOpen: \start end -> IntOpenRange#new(start, end) as Range Int32
    }

pub instance
rangedInt64 : Ranged Int64
rangedInt64 =
  Ranged
    { range: \start end -> LongRange#new(start, end) as Range Int64
    , rangeOpen: \start end -> LongOpenRange#new(start, end) as Range Int64
    }

pub instance
rangedFloat32 : Ranged Float32
rangedFloat32 =
  Ranged
    { range: \start end -> FloatRange#new(start, end) as Range Float32
    , rangeOpen: \start end -> FloatOpenRange#new(start, end) as Range Float32
    }

pub instance
rangedFloat64 : Ranged Float64
rangedFloat64 =
  Ranged
    { range: \start end -> DoubleRange#new(start, end) as Range Float64
    , rangeOpen: \start end -> DoubleOpenRange#new(start, end) as Range Float64
    }

pub instance
rangedChar : Ranged Char
rangedChar =
  Ranged
    { range: \start end -> CharRange#new(start, end) as Range Char
    , rangeOpen: \start end -> CharOpenRange#new(start, end) as Range Char
    }

pub instance
rangedBigInt : Ranged BigInteger
rangedBigInt =
  Ranged
    { range: \start end -> BigIntRange#new(start, end) as Range BigInteger
    , rangeOpen: \start end -> BigIntOpenRange#new(start, end) as Range BigInteger
    }

pub instance
rangedBigDecimal : Ranged BigDecimal
rangedBigDecimal =
  Ranged
    { range: \start end -> BigDecimalRange#new(start, end) as Range BigDecimal
    , rangeOpen: \start end -> BigDecimalOpenRange#new(start, end) as Range BigDecimal
    }

pub instance
rangedStepInt32 : RangedStep Int32
rangedStepInt32 =
  RangedStep
    { range: \start end step -> IntRange#new(start, end, step) as Range Int32
    , rangeOpen: \start end step -> IntOpenRange#new(start, end, step) as Range Int32
    }

pub instance
rangedStepInt64 : RangedStep Int64
rangedStepInt64 =
  RangedStep
    { range: \start end step -> LongRange#new(start, end, step) as Range Int64
    , rangeOpen: \start end step -> LongOpenRange#new(start, end, step) as Range Int64
    }

pub instance
rangedStepChar : RangedStep Char
rangedStepChar =
  RangedStep
    { range: \start end step -> CharRange#new(start, end, Core#charToInt(step)) as Range Char
    , rangeOpen: \start end step -> CharOpenRange#new(start, end, Core#charToInt(step)) as Range Char
    }

pub instance
rangedStepBigInt : RangedStep BigInteger
rangedStepBigInt =
  RangedStep
    { range: \start end step -> BigIntRange#new(start, end, step) as Range BigInteger
    , rangeOpen: \start end step -> BigIntOpenRange#new(start, end, step) as Range BigInteger
    }

// The type of things that can be closed.
// Similar to `java.lang.AutoCloseable`.
pub+
type AutoCloseable a = AutoCloseable { close : a -> Unit }

// Runs the function and closes the resource afterwards.
// Similar to Java's try-with-resource.
pub
withOpen : {{ AutoCloseable a }} -> a -> (a -> b) -> b
withOpen {{AutoCloseable {close}}} res f =
  try
    f res
  finally
    close res